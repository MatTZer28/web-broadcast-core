/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["webBroadcastCore"] = factory();
	else
		root["webBroadcastCore"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/display/scenes-wrapper.js":
/*!***************************************!*\
  !*** ./src/display/scenes-wrapper.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScenesWrapper\": () => (/* binding */ ScenesWrapper)\n/* harmony export */ });\nconst { Scene } = __webpack_require__(/*! ../lib/scene */ \"./src/lib/scene.js\");\n\nclass ScenesWrapper {\n    constructor(WBS) {\n        this._WBS = WBS;\n        \n        this._scenes = [];\n    }\n\n    createScene() {\n        const scene = new Scene(this._WBS);\n\n        this._scenes.push(scene);\n        this._WBS.addStageChild(scene);\n\n        return scene;\n    }\n\n    getScenesLength() {\n        return this._scenes.length;\n    }\n\n    getScene(sceneIndex) {\n        return this._scenes[sceneIndex];\n    }\n\n    removeScene(sceneIndex) {\n        this._scenes[sceneIndex].destroy();\n        this._scenes.splice(sceneIndex, 1);\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/display/scenes-wrapper.js?");

/***/ }),

/***/ "./src/display/sources-wrapper.js":
/*!****************************************!*\
  !*** ./src/display/sources-wrapper.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SourcesWrapper\": () => (/* binding */ SourcesWrapper)\n/* harmony export */ });\nconst { FocusBox } = __webpack_require__(/*! ../lib/focus-box */ \"./src/lib/focus-box.js\");\nconst { Virtual } = __webpack_require__(/*! ../lib/source/virtual */ \"./src/lib/source/virtual.js\");\nconst { Image } = __webpack_require__(/*! ../lib/source/image */ \"./src/lib/source/image.js\");\nconst { Video } = __webpack_require__(/*! ../lib/source/video */ \"./src/lib/source/video.js\");\nconst { Text } = __webpack_require__(/*! ../lib/source/text */ \"./src/lib/source/text.js\");\nconst { DisplayMedia } = __webpack_require__(/*! ../lib/display-media */ \"./src/lib/display-media.js\");\n\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\n\nclass SourcesWrapper {\n    constructor(WBS, parentScene) {\n        this._WBS = WBS;\n\n        this._parentScene = parentScene;\n\n        this._sources = [];\n\n        this.focusBox = new FocusBox(this._WBS);\n        this.focusBox.zIndex = 2;\n\n        this._parentScene.addChild(this.focusBox);\n    }\n\n    async createVirtualModel(sourcePath) {\n        const source = new Virtual(this._WBS, this);\n        \n        await source.loadModel(sourcePath);\n\n        source.zIndex = 2;\n\n        return source;\n    }\n\n    createImageSource(sourcePath) {\n        const sourceTexture = PIXI.Texture.from(sourcePath);\n\n        const source = new Image(this._WBS, this, sourceTexture);\n\n        return source;\n    }\n\n    async createVideoSource() {\n        const displayMedia = new DisplayMedia();\n\n        const sourceTexture = PIXI.Texture.from(await displayMedia.createVideoTexture());\n\n        const source = new Video(this._WBS, this, sourceTexture);\n\n        return source;\n    }\n\n    createTextSource(text, style) {\n        style = style || {};\n        \n        const source = new Text(this._WBS, this, text, style);\n\n        return source;\n    }\n\n    addSource(source) {\n        this._sources.push(source);\n        this._parentScene.addChild(source);\n    }\n\n    getSource(sourceIndex) {\n        return this._sources[sourceIndex];\n    }\n\n    removeSource(sourceIndex) {\n        this._sources[sourceIndex].destroy();\n        this._sources.splice(sourceIndex, 1);\n    }\n\n    unfocusedWithout(source, state) {\n        this._sources.forEach(s=> {\n            if (s !== source) {\n                s.setOnFoucsState(state);\n            }\n        });\n    }\n\n    disableInteractiveWithout(source, state) {\n        this._sources.forEach(s => {\n            if (s !== source) {\n                s.setInteractiveState(state);\n            }\n        });\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/display/sources-wrapper.js?");

/***/ }),

/***/ "./src/lib/display-media.js":
/*!**********************************!*\
  !*** ./src/lib/display-media.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DisplayMedia\": () => (/* binding */ DisplayMedia)\n/* harmony export */ });\nclass DisplayMedia {\n    constructor() {\n        this._displayMediaOptions = {\n            video: {\n              cursor: \"always\",\n              frameRate: { ideal: 60, max: 60 }\n            },\n            audio: true\n          };\n    }\n\n    async createVideoTexture() { \n      const mediaDevices = navigator.mediaDevices;\n\n      const videoElement = document.createElement('video');\n      videoElement.srcObject = await mediaDevices.getDisplayMedia(this._displayMediaOptions);\n\n      return videoElement;\n    }\n\n    closeMediaStream() {\n      const tracks = this._mediaStream.getTracks();\n      \n      tracks.forEach(track => track.stop());\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/display-media.js?");

/***/ }),

/***/ "./src/lib/focus-box.js":
/*!******************************!*\
  !*** ./src/lib/focus-box.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FocusBox\": () => (/* binding */ FocusBox)\n/* harmony export */ });\nconst { Video } = __webpack_require__(/*! ../lib/source/video */ \"./src/lib/source/video.js\");\n\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\n\nclass FocusBox extends PIXI.Container {\n    constructor(WBS) {\n        super();\n\n        this._WBS = WBS;\n\n        this._resizeing = false;\n\n        this._focusBox = {\n            border: new PIXI.Graphics(),\n            topLeft: new PIXI.Graphics(),\n            topMiddle: new PIXI.Graphics(),\n            topRight: new PIXI.Graphics(),\n            middleLeft: new PIXI.Graphics(),\n            middleRight: new PIXI.Graphics(),\n            bottomLeft: new PIXI.Graphics(),\n            bottomMiddle: new PIXI.Graphics(),\n            bottomRight: new PIXI.Graphics(),\n        };\n\n        for (const [key, value] of Object.entries(this._focusBox)) {this.addChild(value);}\n\n        this._setScaleInteraction();\n        \n        this._setGlobalInteraction();\n    }\n\n    _setScaleInteraction() {\n        this._setTopLeftScaleInteraction();\n        this._setTopMiddleScaleInteraction();\n        this._setTopRightScaleInteraction();\n        this._setMiddleLeftScaleInteraction();\n        this._setMiddleRightScaleInteraction();\n        this._setBottomLeftScaleInteraction();\n        this._setBottomMiddleScaleInteraction();\n        this._setBottomRightScaleInteraction();\n    }\n\n    _setTopLeftScaleInteraction() {\n        this._focusBox['topLeft'].interactive = true;\n        this._focusBox['topLeft'].on(\"mousedown\", this._topLeftOnMouseDown, this);\n        this._focusBox['topLeft'].on(\"mousemove\", this._topLeftOnMouseMove, this);\n        this._focusBox['topLeft'].on(\"mouseup\", this._topLeftOnMouseUp, this);\n        this._focusBox['topLeft'].on(\"mouseover\", this._topLeftOnMouseOver, this);\n        this._focusBox['topLeft'].on(\"mouseout\", this._topLeftOnMouseOut, this);\n    }\n\n    _topLeftOnMouseDown(event) {\n        this._focusedTarget.setDragging(false);\n        this._resizeing = 'topLeft';\n        this._focusBox[\"border\"].prevInteractX = event.data.global.x;\n        this._focusBox[\"border\"].prevInteractY = event.data.global.y;\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\n    }\n\n    _topLeftOnMouseMove(event) {\n        if (event.data.global.x < 0 || event.data.global.x > this._WBS.appWidth) return;\n        if (event.data.global.y > this._WBS.appHeight || event.data.global.y < 0) return;\n        if (this._resizeing === 'topLeft') {\n            const rightX = this._focusBox[\"border\"].prevInteractX + this._focusBox[\"border\"].originWidth;\n            const bottomY = this._focusBox[\"border\"].prevInteractY + this._focusBox[\"border\"].originHeight;\n\n            const isCurrXTooOver = event.data.global.x > rightX;\n            const isCurrYTooOver = event.data.global.y > bottomY;\n\n            const deltaX = this._focusBox[\"border\"].prevInteractX - event.data.global.x;\n            const deltaY = this._focusBox[\"border\"].prevInteractY - event.data.global.y;\n\n            const width = this._focusBox[\"border\"].originWidth;\n            const height = this._focusBox[\"border\"].originHeight;\n\n            if (isCurrXTooOver && isCurrYTooOver) {\n                this.drawFocusBox(rightX, bottomY, 1, 1);\n\n                const resizeX = rightX;\n                const resizeY = bottomY;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n                return;\n            }\n\n            if (isCurrXTooOver) {\n                this.drawFocusBox(rightX, event.data.global.y, 1, height + deltaY);\n\n                const resizeX = rightX;\n                const resizeY = event.data.global.y + this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            } else if (isCurrYTooOver) {\n                this.drawFocusBox(event.data.global.x, bottomY, width + deltaX, 1);\n\n                const resizeX = event.data.global.x + this._focusBox[\"border\"].width / 2;\n                const resizeY = bottomY;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            } else {\n                this.drawFocusBox(event.data.global.x, event.data.global.y, width + deltaX, height + deltaY);\n\n                const resizeX = event.data.global.x + this._focusBox[\"border\"].width / 2;\n                const resizeY = event.data.global.y + this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            }\n        }\n    }\n\n    _topLeftOnMouseUp(event) {\n        this._resizeing = null;\n    }\n\n    _topLeftOnMouseOver(event) {\n        this._WBS.setCursor(\"nwse-resize\");\n    }\n\n    _topLeftOnMouseOut(event) {\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _setTopMiddleScaleInteraction() {\n        this._focusBox['topMiddle'].interactive = true;\n        this._focusBox['topMiddle'].on(\"mousedown\", this._topMiddleOnMouseDown, this);\n        this._focusBox['topMiddle'].on(\"mousemove\", this._topMiddleOnMouseMove, this);\n        this._focusBox['topMiddle'].on(\"mouseup\", this._topMiddleOnMouseUp, this);\n        this._focusBox['topMiddle'].on(\"mouseover\", this._topMiddleOnMouseOver, this);\n        this._focusBox['topMiddle'].on(\"mouseout\", this._topMiddleOnMouseOut, this);\n    }\n\n    _topMiddleOnMouseDown(event) {\n        this._focusedTarget.setDragging(false);\n        this._resizeing = 'topMiddle';\n        this._focusBox[\"border\"].prevInteractY = event.data.global.y;\n        this._focusBox[\"border\"].originX = event.data.global.x - this._focusBox[\"border\"].width / 2;\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\n    }\n\n    _topMiddleOnMouseMove(event) {\n        if (event.data.global.y > this._WBS.appHeight || event.data.global.y < 0) return;\n        if (this._resizeing === 'topMiddle') {\n            const bottomY = this._focusBox[\"border\"].prevInteractY + this._focusBox[\"border\"].originHeight;\n\n            const isCurrYTooOver = event.data.global.y > bottomY;\n\n            const deltaY = this._focusBox[\"border\"].prevInteractY - event.data.global.y;\n\n            const width = this._focusBox[\"border\"].originWidth;\n            const height = this._focusBox[\"border\"].originHeight;\n\n            if (isCurrYTooOver) {\n                this.drawFocusBox(this._focusBox[\"border\"].originX, bottomY, width, 1);\n\n                const resizeX = this._focusBox[\"border\"].originX + this._focusBox[\"border\"].width / 2;\n                const resizeY = bottomY;\n\n                this._focusedTarget.resize(resizeX, resizeY, width, this._focusBox[\"border\"].height);\n                return;\n            }\n\n            this.drawFocusBox(this._focusBox[\"border\"].originX, event.data.global.y, width, height + deltaY);\n\n            const resizeX = this._focusBox[\"border\"].originX + this._focusBox[\"border\"].width / 2;\n            const resizeY = event.data.global.y + this._focusBox[\"border\"].height / 2;\n\n            this._focusedTarget.resize(resizeX, resizeY, width, this._focusBox[\"border\"].height);\n        }\n    }\n\n    _topMiddleOnMouseUp(event) {\n        this._resizeing = null;\n    }\n\n    _topMiddleOnMouseOver(event) {\n        this._WBS.setCursor(\"ns-resize\");\n    }\n\n    _topMiddleOnMouseOut(event) {\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _setTopRightScaleInteraction() {\n        this._focusBox['topRight'].interactive = true;\n        this._focusBox['topRight'].on(\"mousedown\", this._topRightOnMouseDown, this);\n        this._focusBox['topRight'].on(\"mousemove\", this._topRightOnMouseMove, this);\n        this._focusBox['topRight'].on(\"mouseup\", this._topRightOnMouseUp, this);\n        this._focusBox['topRight'].on(\"mouseover\", this._topRightOnMouseOver, this);\n        this._focusBox['topRight'].on(\"mouseout\", this._topRightOnMouseOut, this);\n    }\n\n    _topRightOnMouseDown(event) {\n        this._focusedTarget.setDragging(false);\n        this._resizeing = 'topRight';\n        this._focusBox[\"border\"].prevInteractX = event.data.global.x;\n        this._focusBox[\"border\"].prevInteractY = event.data.global.y;\n        this._focusBox[\"border\"].originX = event.data.global.x - this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\n    }\n\n    _topRightOnMouseMove(event) {\n        if (event.data.global.x < 0 || event.data.global.x > this._WBS.appWidth) return;\n        if (event.data.global.y > this._WBS.appHeight || event.data.global.y < 0) return;\n        if (this._resizeing === 'topRight') {\n            const leftX = this._focusBox[\"border\"].originX;\n            const bottomY = this._focusBox[\"border\"].prevInteractY + this._focusBox[\"border\"].originHeight;\n\n            const isCurrXTooOver = event.data.global.x < leftX;\n            const isCurrYTooOver = event.data.global.y > bottomY;\n\n            const deltaX = event.data.global.x - this._focusBox[\"border\"].prevInteractX;\n            const deltaY = this._focusBox[\"border\"].prevInteractY - event.data.global.y;\n\n            const width = this._focusBox[\"border\"].originWidth;\n            const height = this._focusBox[\"border\"].originHeight;\n\n            if (isCurrXTooOver && isCurrYTooOver) {\n                this.drawFocusBox(leftX, bottomY, 1, 1);\n\n                const resizeX = leftX;\n                const resizeY = bottomY;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n                return;\n            }\n\n            if (isCurrXTooOver) {\n                this.drawFocusBox(leftX, event.data.global.y, 1, height + deltaY);\n\n                const resizeX = leftX;\n                const resizeY = event.data.global.y + this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            } else if (isCurrYTooOver) {\n                this.drawFocusBox(this._focusBox[\"border\"].originX, bottomY, width + deltaX, 1);\n\n                const resizeX = event.data.global.x - this._focusBox[\"border\"].width / 2;\n                const resizeY = bottomY;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            } else {\n                this.drawFocusBox(this._focusBox[\"border\"].originX, event.data.global.y, width + deltaX, height + deltaY);\n\n                const resizeX = event.data.global.x - this._focusBox[\"border\"].width / 2;\n                const resizeY = event.data.global.y + this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            }\n        }\n    }\n\n    _topRightOnMouseUp(event) {\n        this._resizeing = null;\n    }\n\n    _topRightOnMouseOver(event) {\n        this._WBS.setCursor(\"ne-resize\");\n    }\n\n    _topRightOnMouseOut(event) {\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _setMiddleLeftScaleInteraction() {\n        this._focusBox['middleLeft'].interactive = true;\n        this._focusBox['middleLeft'].on(\"mousedown\", this._middleLeftOnMouseDown, this);\n        this._focusBox['middleLeft'].on(\"mousemove\", this._middleLeftOnMouseMove, this);\n        this._focusBox['middleLeft'].on(\"mouseup\", this._middleLeftOnMouseUp, this);\n        this._focusBox['middleLeft'].on(\"mouseover\", this._middleLeftOnMouseOver, this);\n        this._focusBox['middleLeft'].on(\"mouseout\", this._middleLeftOnMouseOut, this);\n    }\n\n    _middleLeftOnMouseDown(event) {\n        this._focusedTarget.setDragging(false);\n        this._resizeing = 'middleLeft';\n        this._focusBox[\"border\"].prevInteractX = event.data.global.x;\n        this._focusBox[\"border\"].originY = event.data.global.y - this._focusBox[\"border\"].height / 2;\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\n    }\n\n    _middleLeftOnMouseMove(event) {\n        if (event.data.global.x < 0 || event.data.global.x > this._WBS.appWidth) return;\n        if (this._resizeing === 'middleLeft') {\n            const rightX = this._focusBox[\"border\"].prevInteractX + this._focusBox[\"border\"].originWidth;\n\n            const isCurrXTooOver = event.data.global.x > rightX;\n\n            const deltaX = this._focusBox[\"border\"].prevInteractX - event.data.global.x;\n\n            const width = this._focusBox[\"border\"].originWidth;\n            const height = this._focusBox[\"border\"].originHeight;\n\n            if (isCurrXTooOver) {\n                this.drawFocusBox(rightX, this._focusBox[\"border\"].originY, 1, height);\n\n                const resizeX = rightX;\n                const resizeY = this._focusBox[\"border\"].originY + this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n                return;\n            }\n\n            this.drawFocusBox(event.data.global.x, this._focusBox[\"border\"].originY, width + deltaX, height);\n\n            const resizeX = event.data.global.x + this._focusBox[\"border\"].width / 2;\n            const resizeY = this._focusBox[\"border\"].originY + this._focusBox[\"border\"].height / 2;\n\n            this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n        }\n    }\n\n    _middleLeftOnMouseUp(event) {\n        this._resizeing = null;\n    }\n\n    _middleLeftOnMouseOver(event) {\n        this._WBS.setCursor(\"w-resize\");\n    }\n\n    _middleLeftOnMouseOut(event) {\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _setMiddleRightScaleInteraction() {\n        this._focusBox['middleRight'].interactive = true;\n        this._focusBox['middleRight'].on(\"mousedown\", this._middleRightOnMouseDown, this);\n        this._focusBox['middleRight'].on(\"mousemove\", this._middleRightOnMouseMove, this);\n        this._focusBox['middleRight'].on(\"mouseup\", this._middleRightOnMouseUp, this);\n        this._focusBox['middleRight'].on(\"mouseover\", this._middleRightOnMouseOver, this);\n        this._focusBox['middleRight'].on(\"mouseout\", this._middleRightOnMouseOut, this);\n    }\n\n    _middleRightOnMouseDown(event) {\n        this._focusedTarget.setDragging(false);\n        this._resizeing = 'middleRight';\n        this._focusBox[\"border\"].prevInteractX = event.data.global.x;\n        this._focusBox[\"border\"].originX = event.data.global.x - this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originY = event.data.global.y - this._focusBox[\"border\"].height / 2;\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\n    }\n\n    _middleRightOnMouseMove(event) {\n        if (event.data.global.x < 0 || event.data.global.x > this._WBS.appWidth) return;\n        if (this._resizeing === 'middleRight') {\n            const leftX = this._focusBox[\"border\"].originX;\n\n            const isCurrXTooOver = event.data.global.x < leftX;\n\n            const deltaX = event.data.global.x - this._focusBox[\"border\"].prevInteractX;\n\n            const width = this._focusBox[\"border\"].originWidth;\n            const height = this._focusBox[\"border\"].originHeight;\n\n            if (isCurrXTooOver) {\n                this.drawFocusBox(leftX, this._focusBox[\"border\"].originY, 1, height);\n\n                const resizeX = leftX;\n                const resizeY = this._focusBox[\"border\"].originY + this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n                return;\n            }\n\n            this.drawFocusBox(this._focusBox[\"border\"].originX, this._focusBox[\"border\"].originY, width + deltaX, height);\n\n            const resizeX = event.data.global.x - this._focusBox[\"border\"].width / 2;\n            const resizeY = this._focusBox[\"border\"].originY + this._focusBox[\"border\"].height / 2;\n\n            this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n        }\n    }\n\n    _middleRightOnMouseUp(event) {\n        this._resizeing = null;\n    }\n\n    _middleRightOnMouseOver(event) {\n        this._WBS.setCursor(\"e-resize\");\n    }\n\n    _middleRightOnMouseOut(event) {\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _setBottomLeftScaleInteraction() {\n        this._focusBox['bottomLeft'].interactive = true;\n        this._focusBox['bottomLeft'].on(\"mousedown\", this._bottomLeftOnMouseDown, this);\n        this._focusBox['bottomLeft'].on(\"mousemove\", this._bottomLeftOnMouseMove, this);\n        this._focusBox['bottomLeft'].on(\"mouseup\", this._bottomLeftOnMouseUp, this);\n        this._focusBox['bottomLeft'].on(\"mouseover\", this._bottomLeftOnMouseOver, this);\n        this._focusBox['bottomLeft'].on(\"mouseout\", this._bottomLeftOnMouseOut, this);\n    }\n\n    _bottomLeftOnMouseDown(event) {\n        this._focusedTarget.setDragging(false);\n        this._resizeing = 'bottomLeft';\n        this._focusBox[\"border\"].prevInteractX = event.data.global.x;\n        this._focusBox[\"border\"].prevInteractY = event.data.global.y;\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\n    }\n\n    _bottomLeftOnMouseMove(event) {\n        if (event.data.global.x < 0 || event.data.global.x > this._WBS.appWidth) return;\n        if (event.data.global.y > this._WBS.appHeight || event.data.global.y < 0) return;\n        if (this._resizeing === 'bottomLeft') {\n            const rightX = this._focusBox[\"border\"].prevInteractX + this._focusBox[\"border\"].originWidth;\n            const topY = this._focusBox[\"border\"].prevInteractY - this._focusBox[\"border\"].originHeight;\n\n            const isCurrXTooOver = event.data.global.x > rightX;\n            const isCurrYTooOver = event.data.global.y < topY;\n\n            const deltaX = this._focusBox[\"border\"].prevInteractX - event.data.global.x;\n            const deltaY = event.data.global.y - this._focusBox[\"border\"].prevInteractY;\n\n            const width = this._focusBox[\"border\"].originWidth;\n            const height = this._focusBox[\"border\"].originHeight;\n\n            if (isCurrXTooOver && isCurrYTooOver) {\n                this.drawFocusBox(rightX, topY, 1, 1);\n\n                const resizeX = rightX;\n                const resizeY = topY;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n                return;\n            }\n\n            if (isCurrXTooOver) {\n                this.drawFocusBox(rightX, event.data.global.y - this._focusBox[\"border\"].height, 1, height + deltaY);\n\n                const resizeX = rightX;\n                const resizeY = event.data.global.y - this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            } else if (isCurrYTooOver) {\n                this.drawFocusBox(event.data.global.x, topY, width + deltaX, 1);\n\n                const resizeX = event.data.global.x + this._focusBox[\"border\"].width / 2;\n                const resizeY = topY;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            } else {\n                this.drawFocusBox(event.data.global.x, event.data.global.y - this._focusBox[\"border\"].height, width + deltaX, height + deltaY);\n\n                const resizeX = event.data.global.x + this._focusBox[\"border\"].width / 2;\n                const resizeY = event.data.global.y - this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            }\n        }\n    }\n\n    _bottomLeftOnMouseUp(event) {\n        this._resizeing = null;\n    }\n\n    _bottomLeftOnMouseOver(event) {\n        this._WBS.setCursor(\"ne-resize\");\n    }\n\n    _bottomLeftOnMouseOut(event) {\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _setBottomMiddleScaleInteraction() {\n        this._focusBox['bottomMiddle'].interactive = true;\n        this._focusBox['bottomMiddle'].on(\"mousedown\", this._bottomMiddleOnMouseDown, this);\n        this._focusBox['bottomMiddle'].on(\"mousemove\", this._bottomMiddleOnMouseMove, this);\n        this._focusBox['bottomMiddle'].on(\"mouseup\", this._bottomMiddleOnMouseUp, this);\n        this._focusBox['bottomMiddle'].on(\"mouseover\", this._bottomMiddleOnMouseOver, this);\n        this._focusBox['bottomMiddle'].on(\"mouseout\", this._bottomMiddleOnMouseOut, this);\n    }\n\n    _bottomMiddleOnMouseDown(event) {\n        this._focusedTarget.setDragging(false);\n        this._resizeing = 'bottomMiddle';\n        this._focusBox[\"border\"].prevInteractY = event.data.global.y;\n        this._focusBox[\"border\"].originX = event.data.global.x - this._focusBox[\"border\"].width / 2;\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\n    }\n\n    _bottomMiddleOnMouseMove(event) {\n        if (event.data.global.y > this._WBS.appHeight || event.data.global.y < 0) return;\n        if (this._resizeing === 'bottomMiddle') {\n            const topY = this._focusBox[\"border\"].prevInteractY - this._focusBox[\"border\"].originHeight;\n\n            const isCurrYTooOver = event.data.global.y < topY;\n\n            const deltaY = event.data.global.y - this._focusBox[\"border\"].prevInteractY;\n\n            const width = this._focusBox[\"border\"].originWidth;\n            const height = this._focusBox[\"border\"].originHeight;\n\n            if (isCurrYTooOver) {\n                this.drawFocusBox(this._focusBox[\"border\"].originX, topY, width, 1);\n\n                const resizeX = this._focusBox[\"border\"].originX + this._focusBox[\"border\"].width / 2;\n                const resizeY = topY;\n\n                this._focusedTarget.resize(resizeX, resizeY, width, this._focusBox[\"border\"].height);\n                return;\n            }\n\n            this.drawFocusBox(this._focusBox[\"border\"].originX, event.data.global.y - this._focusBox[\"border\"].height, width, height + deltaY);\n\n            const resizeX = this._focusBox[\"border\"].originX + this._focusBox[\"border\"].width / 2;\n            const resizeY = event.data.global.y - this._focusBox[\"border\"].height / 2;\n\n            this._focusedTarget.resize(resizeX, resizeY, width, this._focusBox[\"border\"].height);\n        }\n    }\n\n    _bottomMiddleOnMouseUp(event) {\n        this._resizeing = null;\n    }\n\n    _bottomMiddleOnMouseOver(event) {\n        this._WBS.setCursor(\"s-resize\");\n    }\n\n    _bottomMiddleOnMouseOut(event) {\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _setBottomRightScaleInteraction() {\n        this._focusBox['bottomRight'].interactive = true;\n        this._focusBox['bottomRight'].on(\"mousedown\", this._bottomRightOnMouseDown, this);\n        this._focusBox['bottomRight'].on(\"mousemove\", this._bottomRightOnMouseMove, this);\n        this._focusBox['bottomRight'].on(\"mouseup\", this._bottomRightOnMouseUp, this);\n        this._focusBox['bottomRight'].on(\"mouseover\", this._bottomRightOnMouseOver, this);\n        this._focusBox['bottomRight'].on(\"mouseout\", this._bottomRightOnMouseOut, this);\n    }\n\n    _bottomRightOnMouseDown(event) {\n        this._focusedTarget.setDragging(false);\n        this._resizeing = 'bottomRight';\n        this._focusBox[\"border\"].prevInteractX = event.data.global.x;\n        this._focusBox[\"border\"].prevInteractY = event.data.global.y;\n        this._focusBox[\"border\"].originX = event.data.global.x - this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\n    }\n\n    _bottomRightOnMouseMove(event) {\n        if (event.data.global.x < 0 || event.data.global.x > this._WBS.appWidth) return;\n        if (event.data.global.y > this._WBS.appHeight || event.data.global.y < 0) return;\n        if (this._resizeing === 'bottomRight') {\n            const leftX = this._focusBox[\"border\"].originX;\n            const topY = this._focusBox[\"border\"].prevInteractY - this._focusBox[\"border\"].originHeight;\n\n            const isCurrXTooOver = event.data.global.x < leftX;\n            const isCurrYTooOver = event.data.global.y < topY;\n\n            const deltaX = event.data.global.x - this._focusBox[\"border\"].prevInteractX;\n            const deltaY = event.data.global.y - this._focusBox[\"border\"].prevInteractY;\n\n            const width = this._focusBox[\"border\"].originWidth;\n            const height = this._focusBox[\"border\"].originHeight;\n\n            if (isCurrXTooOver && isCurrYTooOver) {\n                this.drawFocusBox(leftX, topY, 1, 1);\n\n                const resizeX = leftX;\n                const resizeY = topY;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n                return;\n            }\n\n            if (isCurrXTooOver) {\n                this.drawFocusBox(leftX, event.data.global.y - this._focusBox[\"border\"].height, 1, height + deltaY);\n\n                const resizeX = leftX;\n                const resizeY = event.data.global.y - this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            } else if (isCurrYTooOver) {\n                this.drawFocusBox(this._focusBox[\"border\"].originX, topY, width + deltaX, 1);\n\n                const resizeX = event.data.global.x - this._focusBox[\"border\"].width / 2;\n                const resizeY = topY;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            } else {\n                this.drawFocusBox(this._focusBox[\"border\"].originX, event.data.global.y - this._focusBox[\"border\"].height, width + deltaX, height + deltaY);\n\n                const resizeX = event.data.global.x - this._focusBox[\"border\"].width / 2;\n                const resizeY = event.data.global.y - this._focusBox[\"border\"].height / 2;\n\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\n            }\n        }\n    }\n\n    _bottomRightOnMouseUp(event) {\n        this._resizeing = null;\n    }\n\n    _bottomRightOnMouseOver(event) {\n        this._WBS.setCursor(\"se-resize\");\n    }\n\n    _bottomRightOnMouseOut(event) {\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _setGlobalInteraction() {\n        document.body.addEventListener('mouseup', e => {\n            this._resizeing = null;\n        });\n    }\n\n    getFocusBox() {\n        return this._focusBox;\n    }\n\n    setFocusedTarget(focusedTarget) {\n        this._focusedTarget = focusedTarget;\n        if (this._focusedTarget instanceof Video) this._onFocusTargetUpdate();\n    }\n\n    _onFocusTargetUpdate() {\n        let preWidth = this._focusedTarget.getChildByName('sprite').width;\n        let preHeight = this._focusedTarget.getChildByName('sprite').height;\n        \n        this._focusedTarget.getChildByName('sprite').texture.on(\"update\", () => {\n            if (this._resizeing !== null || !this._focusedTarget.getFocusState() || this._focusedTarget.getDraggingState()) return;\n\n            const width = this._focusedTarget.getChildByName('sprite').width;\n            const height = this._focusedTarget.getChildByName('sprite').height;\n            const x = this._focusedTarget.getChildByName('sprite').x - width / 2;\n            const y = this._focusedTarget.getChildByName('sprite').y - height / 2;\n\n            if (width !== preWidth || height !== preHeight) this.drawFocusBox(x, y, width, height);\n\n            preWidth = this._focusedTarget.getChildByName('sprite').width;\n            preHeight = this._focusedTarget.getChildByName('sprite').height;\n        }, this);\n    }\n\n    drawFocusBox(x, y, width, height) {\n        this.resetFocusBox();\n\n        this._focusBox.border.lineStyle(4, 0xEB4034);\n        this._focusBox.border.drawRect(x, y, width, height);\n\n        const dotWidth = 15;\n        const dotHeight = 15;\n\n        const first = [\"top\", \"middle\", \"bottom\"];\n        const last = [\"Left\", \"Middle\", \"Right\"];\n        let firstPos = 0;\n        let lastPos = 0;\n\n        const leftMiddleRightPosX = [\n            x - (dotWidth / 2),\n            x + (width / 2) - (dotWidth / 2),\n            x + width - (dotWidth / 2),\n        ];\n        const topMiddleBottomPosY = [\n            y - (dotHeight / 2),\n            y + (height / 2) - (dotHeight / 2),\n            y + height - (dotHeight / 2),\n        ];\n\n        topMiddleBottomPosY.forEach(posY => {\n            lastPos = 0;\n            leftMiddleRightPosX.forEach(posX => {\n                if (!(firstPos === 1 && lastPos === 1)) {\n                    this._focusBox[first[firstPos] + last[lastPos]].beginFill(0xEB4034);\n                    this._focusBox[first[firstPos] + last[lastPos]].drawRect(posX, posY, dotWidth, dotHeight);\n                    this._focusBox[first[firstPos] + last[lastPos]].endFill();\n                }\n                lastPos = lastPos + 1;\n            })\n            firstPos = firstPos + 1;\n        })\n    }\n\n    resetFocusBox() {\n        for (const [key, value] of Object.entries(this._focusBox)) {\n            this._focusBox[key].clear();\n            this._focusBox[key].x = 0;\n            this._focusBox[key].y = 0;\n        }\n    }\n\n    moveFocusBox(deltaX, deltaY) {\n        for (const [key, value] of Object.entries(this._focusBox)) {\n            this._focusBox[key].x = this._focusBox[key].x + deltaX;\n            this._focusBox[key].y = this._focusBox[key].y + deltaY;\n        }\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/focus-box.js?");

/***/ }),

/***/ "./src/lib/scene.js":
/*!**************************!*\
  !*** ./src/lib/scene.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scene\": () => (/* binding */ Scene)\n/* harmony export */ });\nconst { SourcesWrapper } = __webpack_require__(/*! ../display/sources-wrapper */ \"./src/display/sources-wrapper.js\");\n\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\n\nclass Scene extends PIXI.Container {\n    constructor(WBS) {\n        super();\n\n        this._WBS = WBS;\n\n        this._sourcesWrapper = new SourcesWrapper(this._WBS, this);\n        \n        this.sortableChildren = true;\n    }\n\n    getSourcesWrapper() {\n        return this._sourcesWrapper;\n    }\n\n    destroy() {\n        this.destroy({\n            children: true,\n            texture: true,\n            baseTexture: true\n        });\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/scene.js?");

/***/ }),

/***/ "./src/lib/source/image.js":
/*!*********************************!*\
  !*** ./src/lib/source/image.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Image\": () => (/* binding */ Image)\n/* harmony export */ });\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\n\nclass Image extends PIXI.Container {\n    constructor(WBS, sourceWrapper, texture) {\n        super();\n\n        this._dragging = false;\n\n        this._focused = false;\n\n        this._WBS = WBS;\n\n        this._sourceWrapper = sourceWrapper;\n\n        this._texture = texture;\n\n        this._sprite = PIXI.Sprite.from(this._texture);\n        this._sprite.name = 'sprite';\n\n        this._blueBox = new PIXI.Graphics();\n\n        this._initSprite();\n\n        this._setSpriteInteraction();\n\n        this._setBackgroundInteraction();\n\n        this._setGlobalInteraction();\n\n        this._addToContainer();\n    }\n\n    _initSprite() {\n        this._sprite.anchor.set(0.5);\n        this._sprite.x = this._WBS.appWidth / 2;\n        this._sprite.y = this._WBS.appHeight / 2;\n        this._focused = false;\n    }\n\n    _setSpriteInteraction() {\n        this.setInteractiveState(true);\n        this._sprite.on(\"mousedown\", this._spriteOnMouseDown, this);\n        this._sprite.on(\"mousemove\", this._spriteOnMouseMove, this);\n        this._sprite.on(\"mouseup\", this._spriteOnMouseUp, this);\n        this._sprite.on(\"mouseover\", this._spriteOnMouseOver, this);\n        this._sprite.on(\"mouseout\", this._spriteOnMouseOut, this);\n    }\n\n    _spriteOnMouseDown(event) {\n        this._blueBox.clear();\n        this._sourceWrapper.focusBox.setFocusedTarget(this);\n        this._showFocusBox();\n\n        this._WBS.setCursor(\"move\");\n\n        this._focused = true;\n        this._dragging = true;\n\n        this._sourceWrapper.unfocusedWithout(this, false);\n        this._sourceWrapper.disableInteractiveWithout(this, false);\n\n        this._sprite.prevInteractX = event.data.global.x;\n        this._sprite.prevInteractY = event.data.global.y;\n    }\n\n    setDragging(state) {\n        this._dragging = state;\n    }\n\n    _showFocusBox() {\n        if (!this._focused) {\n            let width = this._sprite.width;\n            let height = this._sprite.height;\n            let bounds = this._sprite.getBounds();\n            this._sourceWrapper.focusBox.drawFocusBox(bounds.x, bounds.y, width, height);\n        }\n    }\n\n    _spriteOnMouseMove(event) {\n        if (this._dragging) {\n            const deltaX = event.data.global.x - this._sprite.prevInteractX;\n            const deltaY = event.data.global.y - this._sprite.prevInteractY;\n\n            this._moveSprite(deltaX, deltaY);\n            this._sourceWrapper.focusBox.moveFocusBox(deltaX, deltaY);\n\n            this._sprite.prevInteractX = event.data.global.x;\n            this._sprite.prevInteractY = event.data.global.y;\n        }\n    }\n\n    _moveSprite(deltaX, deltaY) {\n        this._sprite.x = this._sprite.x + deltaX;\n        this._sprite.y = this._sprite.y + deltaY;\n    }\n\n    _spriteOnMouseUp(event) {\n        this._dragging = false;\n\n        this._sourceWrapper.disableInteractiveWithout(this, true);\n\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _spriteOnMouseOver(event) {\n        if (!this._focused) {\n            this._drawBlueBox();\n        }\n    }\n\n    _drawBlueBox() {\n        this._blueBox.lineStyle(4, 0x00AEB9);\n        this._blueBox.drawShape(this._sprite.getBounds());\n    }\n\n    _spriteOnMouseOut(event) {\n        if (!this._focused) {\n            this._blueBox.clear();\n        }\n    }\n\n    _setBackgroundInteraction() {\n        this._WBS.background.on('click', (event) => {\n            if (!this._isClickInsideSprite(event.data.global.x, event.data.global.y)) {\n                this._focused = false;\n                this._sourceWrapper.focusBox.resetFocusBox();\n            }\n        }, this);\n    }\n\n    _isClickInsideSprite(x, y) {\n        const isBiggerThanLeft = (x >= this._sprite.x - (this._sprite.width / 2));\n        const isSmallerThanRight = (x <= this._sprite.x + (this._sprite.width / 2));\n        const isInsideSpriteX = (isBiggerThanLeft && isSmallerThanRight);\n\n        const isBiggerThanTop = (y >= this._sprite.y - (this._sprite.height / 2));\n        const isSmallerThanBottom = (y <= this._sprite.y + (this._sprite.height / 2));\n        const isInsideSpriteY = (isBiggerThanTop && isSmallerThanBottom);\n\n        return (isInsideSpriteX && isInsideSpriteY);\n    }\n\n    _setGlobalInteraction() {\n        document.body.addEventListener('mouseup', e => {\n            this._dragging = null;\n        });\n    }\n\n    _addToContainer() {\n        this.addChild(this._sprite);\n        this.addChild(this._blueBox);\n    }\n\n    setOnFoucsState(state) {\n        this._focused = state;\n    }\n\n    setInteractiveState(state) {\n        this._sprite.interactive = state;\n    }\n\n    getFocusState() {\n        return this._focused;\n    }\n\n    getDraggingState() {\n        return this._dragging;\n    }\n\n    resize(x, y, width, height) {\n        this._sprite.x = x;\n        this._sprite.y = y;\n        this._sprite.width = width;\n        this._sprite.height = height;\n    }\n\n    destroy() {\n        this.destroy({\n            children: true,\n            texture: true,\n            baseTexture: true\n        });\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/source/image.js?");

/***/ }),

/***/ "./src/lib/source/text.js":
/*!********************************!*\
  !*** ./src/lib/source/text.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Text\": () => (/* binding */ Text)\n/* harmony export */ });\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\n\nclass Text extends PIXI.Container {\n    constructor(WBS, sourceWrapper, text, style) {\n        super();\n\n        this._dragging = false;\n\n        this._focused = false;\n\n        this._WBS = WBS;\n\n        this._sourceWrapper = sourceWrapper;\n\n        this._sprite = new PIXI.Text(text, style);\n        this._sprite.name = 'sprite';\n\n        this._blueBox = new PIXI.Graphics();\n\n        this._resizeCounter = 0;\n\n        this._initSprite();\n\n        this._setSpriteInteraction();\n\n        this._setBackgroundInteraction();\n\n        this._setGlobalInteraction();\n\n        this._addToContainer();\n    }\n\n    _initSprite() {\n        this._sprite.anchor.set(0.5);\n        this._sprite.x = this._WBS.appWidth / 2;\n        this._sprite.y = this._WBS.appHeight / 2;\n        this._focused = false;\n    }\n\n    _setSpriteInteraction() {\n        this.setInteractiveState(true);\n        this._sprite.on(\"mousedown\", this._spriteOnMouseDown, this);\n        this._sprite.on(\"mousemove\", this._spriteOnMouseMove, this);\n        this._sprite.on(\"mouseup\", this._spriteOnMouseUp, this);\n        this._sprite.on(\"mouseover\", this._spriteOnMouseOver, this);\n        this._sprite.on(\"mouseout\", this._spriteOnMouseOut, this);\n    }\n\n    _spriteOnMouseDown(event) {\n        this._blueBox.clear();\n        this._sourceWrapper.focusBox.setFocusedTarget(this);\n        this._showFocusBox();\n\n        this._WBS.setCursor(\"move\");\n\n        this._focused = true;\n        this._dragging = true;\n\n        this._sourceWrapper.unfocusedWithout(this, false);\n        this._sourceWrapper.disableInteractiveWithout(this, false);\n\n        this._sprite.prevInteractX = event.data.global.x;\n        this._sprite.prevInteractY = event.data.global.y;\n    }\n\n    setDragging(state) {\n        this._dragging = state;\n    }\n\n    _showFocusBox() {\n        if (!this._focused) {\n            let width = this._sprite.width;\n            let height = this._sprite.height;\n            let bounds = this._sprite.getBounds();\n            this._sourceWrapper.focusBox.drawFocusBox(bounds.x, bounds.y, width, height);\n        }\n    }\n\n    _spriteOnMouseMove(event) {\n        if (this._dragging) {\n            const deltaX = event.data.global.x - this._sprite.prevInteractX;\n            const deltaY = event.data.global.y - this._sprite.prevInteractY;\n\n            this._moveSprite(deltaX, deltaY);\n            this._sourceWrapper.focusBox.moveFocusBox(deltaX, deltaY);\n\n            this._sprite.prevInteractX = event.data.global.x;\n            this._sprite.prevInteractY = event.data.global.y;\n        }\n    }\n\n    _moveSprite(deltaX, deltaY) {\n        this._sprite.x = this._sprite.x + deltaX;\n        this._sprite.y = this._sprite.y + deltaY;\n    }\n\n    _spriteOnMouseUp(event) {\n        this._dragging = false;\n\n        this._sourceWrapper.disableInteractiveWithout(this, true);\n\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _spriteOnMouseOver(event) {\n        if (!this._focused) {\n            this._drawBlueBox();\n        }\n    }\n\n    _drawBlueBox() {\n        this._blueBox.lineStyle(4, 0x00AEB9);\n        this._blueBox.drawShape(this._sprite.getBounds());\n    }\n\n    _spriteOnMouseOut(event) {\n        if (!this._focused) {\n            this._blueBox.clear();\n        }\n    }\n\n    _setBackgroundInteraction() {\n        this._WBS.background.on('click', (event) => {\n            if (!this._isClickInsideSprite(event.data.global.x, event.data.global.y)) {\n                this._focused = false;\n                this._sourceWrapper.focusBox.resetFocusBox();\n            }\n        }, this);\n    }\n\n    _isClickInsideSprite(x, y) {\n        const isBiggerThanLeft = (x >= this._sprite.x - (this._sprite.width / 2));\n        const isSmallerThanRight = (x <= this._sprite.x + (this._sprite.width / 2));\n        const isInsideSpriteX = (isBiggerThanLeft && isSmallerThanRight);\n\n        const isBiggerThanTop = (y >= this._sprite.y - (this._sprite.height / 2));\n        const isSmallerThanBottom = (y <= this._sprite.y + (this._sprite.height / 2));\n        const isInsideSpriteY = (isBiggerThanTop && isSmallerThanBottom);\n\n        return (isInsideSpriteX && isInsideSpriteY);\n    }\n\n    _setGlobalInteraction() {\n        document.body.addEventListener('mouseup', e => {\n            this._dragging = null;\n        });\n    }\n\n    _addToContainer() {\n        this.addChild(this._sprite);\n        this.addChild(this._blueBox);\n    }\n\n    setOnFoucsState(state) {\n        this._focused = state;\n    }\n\n    setInteractiveState(state) {\n        this._sprite.interactive = state;\n    }\n\n    getFocusState() {\n        return this._focused;\n    }\n\n    getDraggingState() {\n        return this._dragging;\n    }\n\n    resize(x, y, width, height) {\n        this._sprite.x = x;\n\n        this._sprite.y = y;\n\n        this._sprite.width = width;\n\n        this._sprite.height = height;\n\n        this._resizeCounter++;\n        if (this._resizeCounter > 100) {\n            this._sprite.style.fontSize = height;\n            this._resizeCounter = 0;\n        }\n    }\n\n    destroy() {\n        this.destroy({\n            children: true,\n            texture: true,\n            baseTexture: true\n        });\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/source/text.js?");

/***/ }),

/***/ "./src/lib/source/video.js":
/*!*********************************!*\
  !*** ./src/lib/source/video.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Video\": () => (/* binding */ Video)\n/* harmony export */ });\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\n\nclass Video extends PIXI.Container {\n    constructor(WBS, sourceWrapper, texture) {\n        super();\n\n        this._dragging = false;\n\n        this._focused = false;\n\n        this._WBS = WBS;\n\n        this._sourceWrapper = sourceWrapper;\n\n        this._texture = texture;\n\n        this._sprite = PIXI.Sprite.from(this._texture);\n        this._sprite.name = 'sprite';\n\n        this._blueBox = new PIXI.Graphics();\n\n        this._initSprite();\n\n        this._setSpriteInteraction();\n\n        this._setBackgroundInteraction();\n\n        this._setGlobalInteraction();\n\n        this._setTextureUpdateListener();\n        \n        this._addToContainer();\n    }\n\n    _initSprite() {\n        this._sprite.anchor.set(0.5);\n        this._sprite.x = this._WBS.appWidth / 2;\n        this._sprite.y = this._WBS.appHeight / 2;\n        this._focused = false;\n    }\n\n    _setSpriteInteraction() {\n        this.setInteractiveState(true);\n        this._sprite.on(\"mousedown\", this._spriteOnMouseDown, this);\n        this._sprite.on(\"mousemove\", this._spriteOnMouseMove, this);\n        this._sprite.on(\"mouseup\", this._spriteOnMouseUp, this);\n        this._sprite.on(\"mouseover\", this._spriteOnMouseOver, this);\n        this._sprite.on(\"mouseout\", this._spriteOnMouseOut, this);\n    }\n\n    _spriteOnMouseDown(event) {\n        this._blueBox.clear();\n        this._sourceWrapper.focusBox.setFocusedTarget(this);\n        this._showFocusBox();\n\n        this._WBS.setCursor(\"move\");\n\n        this._focused = true;\n        this._dragging = true;\n\n        this._sourceWrapper.unfocusedWithout(this, false);\n        this._sourceWrapper.disableInteractiveWithout(this, false);\n\n        this._sprite.prevInteractX = event.data.global.x;\n        this._sprite.prevInteractY = event.data.global.y;\n    }\n\n    setDragging(state) {\n        this._dragging = state;\n    }\n\n    _showFocusBox() {\n        if (!this._focused) {\n            let width = this._sprite.width;\n            let height = this._sprite.height;\n            let bounds = this._sprite.getBounds();\n            this._sourceWrapper.focusBox.drawFocusBox(bounds.x, bounds.y, width, height);\n        }\n    }\n\n    _spriteOnMouseMove(event) {\n        if (this._dragging) {\n            const deltaX = event.data.global.x - this._sprite.prevInteractX;\n            const deltaY = event.data.global.y - this._sprite.prevInteractY;\n\n            this._moveSprite(deltaX, deltaY);\n            this._sourceWrapper.focusBox.moveFocusBox(deltaX, deltaY);\n\n            this._sprite.prevInteractX = event.data.global.x;\n            this._sprite.prevInteractY = event.data.global.y;\n        }\n    }\n\n    _moveSprite(deltaX, deltaY) {\n        this._sprite.x = this._sprite.x + deltaX;\n        this._sprite.y = this._sprite.y + deltaY;\n    }\n\n    _spriteOnMouseUp(event) {\n        this._dragging = false;\n\n        this._sourceWrapper.disableInteractiveWithout(this, true);\n\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _spriteOnMouseOver(event) {\n        if (!this._focused) {\n            this._drawBlueBox();\n        }\n    }\n\n    _drawBlueBox() {\n        this._blueBox.lineStyle(4, 0x00AEB9);\n        this._blueBox.drawShape(this._sprite.getBounds());\n    }\n\n    _spriteOnMouseOut(event) {\n        if (!this._focused) {\n            this._blueBox.clear();\n        }\n    }\n\n    _setBackgroundInteraction() {\n        this._WBS.background.on('click', (event) => {\n            if (!this._isClickInsideSprite(event.data.global.x, event.data.global.y)) {\n                this._focused = false;\n                this._sourceWrapper.focusBox.resetFocusBox();\n            }\n        }, this);\n    }\n\n    _isClickInsideSprite(x, y) {\n        const isBiggerThanLeft = (x >= this._sprite.x - (this._sprite.width / 2));\n        const isSmallerThanRight = (x <= this._sprite.x + (this._sprite.width / 2));\n        const isInsideSpriteX = (isBiggerThanLeft && isSmallerThanRight);\n\n        const isBiggerThanTop = (y >= this._sprite.y - (this._sprite.height / 2));\n        const isSmallerThanBottom = (y <= this._sprite.y + (this._sprite.height / 2));\n        const isInsideSpriteY = (isBiggerThanTop && isSmallerThanBottom);\n\n        return (isInsideSpriteX && isInsideSpriteY);\n    }\n\n    _setGlobalInteraction() {\n        document.body.addEventListener('mouseup', e => {\n            this._dragging = null;\n        });\n    }\n\n    _setTextureUpdateListener() {\n        let isSpriteSet = false;\n        let lastBounds = this._sprite.getBounds();\n\n        this._texture.on(\"update\", () => {\n            if (this._texture.width === 2 && this._texture.height === 2) {\n                if (isSpriteSet) return;\n                this._sprite.x = lastBounds.x + lastBounds.width / 2;\n                this._sprite.y = lastBounds.y + lastBounds.height / 2;\n                this._sprite.width = lastBounds.width;\n                this._sprite.height = lastBounds.height;\n                this._sprite.texture = this._createCoverTexture(lastBounds);\n                isSpriteSet = true;\n            } else {\n                if (isSpriteSet) this._sprite.texture = this._texture;\n                isSpriteSet = false;\n                lastBounds = this._sprite.getBounds();\n            }\n        }, this);\n    }\n\n    _createCoverTexture(lastBounds) {\n        let cover = new PIXI.Graphics();\n\n        cover.beginFill(0x5C5C5C, 0.6);\n        cover.drawShape(lastBounds);\n        cover.endFill();\n\n        return this._WBS.getApplication().renderer.generateTexture(cover);\n    }\n\n    _addToContainer() {\n        this.addChild(this._sprite);\n        this.addChild(this._blueBox);\n    }\n\n    setOnFoucsState(state) {\n        this._focused = state;\n    }\n\n    setInteractiveState(state) {\n        this._sprite.interactive = state;\n    }\n\n    getFocusState() {\n        return this._focused;\n    }\n\n    getDraggingState() {\n        return this._dragging;\n    }\n\n    resize(x, y, width, height) {\n        this._sprite.x = x;\n        this._sprite.y = y;\n        this._sprite.width = width;\n        this._sprite.height = height;\n    }\n\n    destroy() {\n        this.destroy({\n            children: true,\n            texture: true,\n            baseTexture: true\n        });\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/source/video.js?");

/***/ }),

/***/ "./src/lib/source/virtual.js":
/*!***********************************!*\
  !*** ./src/lib/source/virtual.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Virtual\": () => (/* binding */ Virtual)\n/* harmony export */ });\n/* harmony import */ var kalidokit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kalidokit */ \"./node_modules/kalidokit/dist/index.js\");\n\n\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\n\n// const { Live2DModel } = require('pixi-live2d-display');\n\nclass Virtual extends PIXI.Container {\n    constructor(WBS, sourceWrapper) {\n        super();\n\n        this._dragging = false;\n\n        this._focused = false;\n\n        this._WBS = WBS;\n\n        this._sourceWrapper = sourceWrapper;\n\n        this._blueBox = new PIXI.Graphics();\n    }\n\n    async loadModel(sourcePath) {\n        this._model = await Live2DModel.from(sourcePath, { autoInteract: false });\n        this._model.name = 'sprite';\n        this._model.internalModel.breath = null;\n\n        this._videoElement = document.createElement('video');\n\n        this._facemesh = new FaceMesh({locateFile: (file) => {\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n        }});\n\n        this._initModel();\n\n        this._setModelInteraction();\n\n        this._setBackgroundInteraction();\n\n        this._setGlobalInteraction();\n\n        this._addToContainer();\n\n        this._motionTracking();\n    }\n\n    _initModel() {\n        this._model.scale.set(0.2);\n        this._model.anchor.set(0.5);\n        this._model.x = this._WBS.appWidth / 2;\n        this._model.y = this._WBS.appHeight / 2;\n        this._focused = false;\n    }\n\n    _setModelInteraction() {\n        this.setInteractiveState(true);\n        this._model.on(\"mousedown\", this._modelOnMouseDown, this);\n        this._model.on(\"mousemove\", this._modelOnMouseMove, this);\n        this._model.on(\"mouseup\", this._modelOnMouseUp, this);\n        this._model.on(\"mouseover\", this._modelOnMouseOver, this);\n        this._model.on(\"mouseout\", this._modelOnMouseOut, this);\n    }\n\n    _modelOnMouseDown(event) {\n        this._blueBox.clear();\n        this._sourceWrapper.focusBox.setFocusedTarget(this);\n        this._showFocusBox();\n\n        this._WBS.setCursor(\"move\");\n\n        this._focused = true;\n        this._dragging = true;\n\n        this._sourceWrapper.unfocusedWithout(this, false);\n        this._sourceWrapper.disableInteractiveWithout(this, false);\n\n        this._model.prevInteractX = event.data.global.x;\n        this._model.prevInteractY = event.data.global.y;\n    }\n\n    setDragging(state) {\n        this._dragging = state;\n    }\n\n    _showFocusBox() {\n        if (!this._focused) {\n            let width = this._model.width;\n            let height = this._model.height;\n            let bounds = this._model.getBounds();\n            this._sourceWrapper.focusBox.drawFocusBox(bounds.x, bounds.y, width, height);\n        }\n    }\n\n    _modelOnMouseMove(event) {\n        if (this._dragging) {\n            const deltaX = event.data.global.x - this._model.prevInteractX;\n            const deltaY = event.data.global.y - this._model.prevInteractY;\n\n            this._moveModel(deltaX, deltaY);\n            this._sourceWrapper.focusBox.moveFocusBox(deltaX, deltaY);\n\n            this._model.prevInteractX = event.data.global.x;\n            this._model.prevInteractY = event.data.global.y;\n        }\n    }\n\n    _moveModel(deltaX, deltaY) {\n        this._model.x = this._model.x + deltaX;\n        this._model.y = this._model.y + deltaY;\n    }\n\n    _modelOnMouseUp(event) {\n        this._dragging = false;\n\n        this._sourceWrapper.disableInteractiveWithout(this, true);\n\n        this._WBS.setCursor(\"auto\");\n    }\n\n    _modelOnMouseOver(event) {\n        if (!this._focused) {\n            this._drawBlueBox();\n        }\n    }\n\n    _drawBlueBox() {\n        this._blueBox.lineStyle(4, 0x00AEB9);\n        this._blueBox.drawShape(this._model.getBounds());\n    }\n\n    _modelOnMouseOut(event) {\n        if (!this._focused) {\n            this._blueBox.clear();\n        }\n    }\n\n    _setBackgroundInteraction() {\n        this._WBS.background.on('click', (event) => {\n            if (!this._isClickInsideModel(event.data.global.x, event.data.global.y)) {\n                this._focused = false;\n                this._sourceWrapper.focusBox.resetFocusBox();\n            }\n        }, this);\n    }\n\n    _isClickInsideModel(x, y) {\n        const isBiggerThanLeft = (x >= this._model.x - (this._model.width / 2));\n        const isSmallerThanRight = (x <= this._model.x + (this._model.width / 2));\n        const isInsideModelX = (isBiggerThanLeft && isSmallerThanRight);\n\n        const isBiggerThanTop = (y >= this._model.y - (this._model.height / 2));\n        const isSmallerThanBottom = (y <= this._model.y + (this._model.height / 2));\n        const isInsideModelY = (isBiggerThanTop && isSmallerThanBottom);\n\n        return (isInsideModelX && isInsideModelY);\n    }\n\n    _setGlobalInteraction() {\n        document.body.addEventListener('mouseup', e => {\n            this._dragging = null;\n        });\n    }\n\n    _addToContainer() {\n        this.addChild(this._model);\n        this.addChild(this._blueBox);\n    }\n\n    _motionTracking() {\n        this._facemesh.setOptions({\n            maxNumFaces: 1,\n            refineLandmarks: true,\n            minDetectionConfidence: 0.5,\n            minTrackingConfidence: 0.5\n        });\n\n        this._facemesh.onResults((results) => {\n            this._animateLive2DModel(results.multiFaceLandmarks[0]);\n        });\n\n        this._startCamera();\n    }\n\n    _animateLive2DModel(points) {\n        if (!this._model || !points) return;\n\n        let riggedFace;\n\n        if (points) {\n            riggedFace = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Face.solve(points, {\n                runtime: \"mediapipe\",\n                video: this._videoElement,\n                smoothBlink: true,\n            });\n            this._rigFace(riggedFace, 0.5);\n        }\n    }\n\n    _rigFace(result, lerpAmount = 0.7) {\n        if (!this._model || !result) return;\n\n        const coreModel = this._model.internalModel.coreModel;\n\n        this._model.internalModel.motionManager.update = (...args) => {\n            this._model.internalModel.eyeBlink = undefined;\n\n            const EyeBallX = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.pupil.x, coreModel.getParameterValueById(\"ParamEyeBallX\"), lerpAmount);\n\n            coreModel.setParameterValueById(\"ParamEyeBallX\", EyeBallX);\n            coreModel.setParameterValueById(\"PARAM_EYE_BALL_X\", EyeBallX);\n\n            const EyeBallY = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.pupil.y, coreModel.getParameterValueById(\"ParamEyeBallY\"), lerpAmount);\n\n            coreModel.setParameterValueById(\"ParamEyeBallY\", EyeBallY);\n            coreModel.setParameterValueById(\"PARAM_EYE_BALL_y\", EyeBallY);\n\n            const angleX = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.y, coreModel.getParameterValueById(\"ParamAngleX\"), lerpAmount);\n\n            coreModel.setParameterValueById(\"ParamAngleX\", angleX);\n            coreModel.setParameterValueById(\"PARAM_ANGLE_X\", angleX);\n\n            const angleY = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.x, coreModel.getParameterValueById(\"ParamAngleY\"), lerpAmount);\n\n            coreModel.setParameterValueById(\"ParamAngleY\", angleY);\n            coreModel.setParameterValueById(\"PARAM_ANGLE_Y\", angleY);\n\n            const angleZ = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.z, coreModel.getParameterValueById(\"ParamAngleZ\"), lerpAmount);\n\n            coreModel.setParameterValueById(\"ParamAngleZ\", angleZ);\n            coreModel.setParameterValueById(\"PARAM_ANGLE_Z\", angleZ);\n\n            const dampener = 0.3;\n            const bodyAngleX = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.y * dampener, coreModel.getParameterValueById(\"ParamBodyAngleX\"), lerpAmount);\n\n            coreModel.setParameterValueById(\"ParamBodyAngleX\", bodyAngleX);\n            coreModel.setParameterValueById(\"PARAM_BODY_ANGLE_X\", bodyAngleX);\n\n            const bodyAngleY = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.x * dampener, coreModel.getParameterValueById(\"ParamBodyAngleY\"), lerpAmount);\n\n\n            coreModel.setParameterValueById(\"ParamBodyAngleY\", bodyAngleY);\n            coreModel.setParameterValueById(\"PARAM_BODY_ANGLE_Y\", bodyAngleY);\n\n            const bodyAngleZ = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.z * dampener, coreModel.getParameterValueById(\"ParamBodyAngleZ\"), lerpAmount);\n\n            coreModel.setParameterValueById(\"ParamBodyAngleZ\", bodyAngleZ);\n            coreModel.setParameterValueById(\"PARAM_BODY_ANGLE_Z\", bodyAngleZ);\n\n            const eyeLOpen = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.eye.l, coreModel.getParameterValueById(\"ParamEyeLOpen\"), 0.5);\n\n            coreModel.setParameterValueById(\"ParamEyeLOpen\", eyeLOpen);\n            coreModel.setParameterValueById(\"PARAM_EYE_L_OPEN\", eyeLOpen);\n\n            const eyeROpen = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.eye.r, coreModel.getParameterValueById(\"ParamEyeROpen\"), 0.5);\n\n\n            coreModel.setParameterValueById(\"ParamEyeROpen\", eyeROpen);\n            coreModel.setParameterValueById(\"PARAM_EYE_R_OPEN\", eyeROpen);\n\n            const mouthOpenY = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.mouth.y, coreModel.getParameterValueById(\"ParamMouthOpenY\"), 0.3);\n\n            coreModel.setParameterValueById(\"ParamMouthOpenY\", mouthOpenY);\n            coreModel.setParameterValueById(\"PARAM_MOUTH_OPEN_Y\", mouthOpenY);\n\n            const mouthForm = 0.3 + kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.mouth.x, coreModel.getParameterValueById(\"ParamMouthForm\"), 0.3);\n\n            coreModel.setParameterValueById(\"ParamMouthForm\", mouthForm);\n            coreModel.setParameterValueById(\"PARAM_MOUTH_FORM\", mouthForm);\n        };\n    }\n\n    _startCamera() {\n        const camera = new Camera(this._videoElement, {\n            onFrame: async () => {\n                await this._facemesh.send({ image: this._videoElement });\n            }\n        });\n\n        camera.start();\n    }\n\n    setOnFoucsState(state) {\n        this._focused = state;\n    }\n\n    setInteractiveState(state) {\n        this._model.interactive = state;\n    }\n\n    getFocusState() {\n        return this._focused;\n    }\n\n    getDraggingState() {\n        return this._dragging;\n    }\n\n    resize(x, y, width, height) {\n        this._model.x = x;\n        this._model.y = y;\n        this._model.width = width;\n        this._model.height = height;\n    }\n\n    destroy() {\n        this.destroy({\n            children: true,\n            texture: true,\n            baseTexture: true\n        });\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/source/virtual.js?");

/***/ }),

/***/ "./src/lib/web-brocast-system.js":
/*!***************************************!*\
  !*** ./src/lib/web-brocast-system.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebBroadcastSystem\": () => (/* binding */ WebBroadcastSystem)\n/* harmony export */ });\nconst { ScenesWrapper } = __webpack_require__(/*! ../display/scenes-wrapper */ \"./src/display/scenes-wrapper.js\");\n\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\n\nclass WebBroadcastSystem {\n    constructor(canvas, appWidth, appHeight) {\n        this.canvas = canvas;\n\n        this.appWidth = appWidth;\n\n        this.appHeight = appHeight;\n        \n        this._pixiApp = this._createApplication();\n\n        this.background = new PIXI.Sprite(PIXI.Texture.WHITE);\n        this._initBackground();\n        \n        this._scenesWrapper = new ScenesWrapper(this);\n    }\n\n    _createApplication() {\n        return new PIXI.Application({\n            width: this.appWidth,\n            height: this.appHeight,\n            backgroundColor: 0xffffff,\n            clearBeforeRender: true,\n            backgroundAlpha: 0,\n            antialias: true,\n            view: this.canvas\n        });\n    }\n\n    _initBackground() {\n        this.background.width = this.appWidth;\n        this.background.height = this.appHeight;\n        this.background.tint = 0xD7D7D6;\n        this.background.interactive = true;\n        this._pixiApp.stage.addChild(this.background);\n    }\n    \n    getApplication() {\n        return this._pixiApp;\n    }\n\n    getScenesWrapper() {\n        return this._scenesWrapper;\n    }\n\n    addStageChild(child) {\n        this._pixiApp.stage.addChild(child);\n    }\n\n    setCursor(mode) {\n        this._pixiApp.view.style.cursor = mode;\n    }\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/web-brocast-system.js?");

/***/ }),

/***/ "./src/worker.js":
/*!***********************!*\
  !*** ./src/worker.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("self.HTMLVideoElement = function HTMLVideoElement() {};\n\nself.HTMLImageElement = function HTMLImageElement() {};\n\nself.HTMLCanvasElement = self.OffscreenCanvas;\n\nself.document = {\n    createElement( type ) {\n        if ( type === 'canvas' )\n        {\n            return new OffscreenCanvas(0, 0);\n        }\n\n        return {\n            style: {}\n        };\n    },\n\n    addEventListener() {},\n};\n\nself.window = {\n    console: self.console,\n\n    addEventListener() {},\n\n    removeEventListener() {},\n\n    navigator: {},\n\n    document: self.document,\n\n    WebGLRenderingContext: self.WebGL2RenderingContext || self.WebGL2RenderingContext,\n\n    requestAnimationFrame: self.requestAnimationFrame.bind(self),\n};\n\nconst { WebBroadcastSystem } = __webpack_require__(/*! ./lib/web-brocast-system */ \"./src/lib/web-brocast-system.js\");\n\nself.addEventListener( 'message', (e) => {\n    const WBS = new WebBroadcastSystem(e.data.canvas, e.data.width, e.data.height);\n})\n\n//# sourceURL=webpack://webBroadcastCore/./src/worker.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_kalidokit_dist_index_js-node_modules_pixi_js_dist_esm_pixi_js"], () => (__webpack_require__("./src/worker.js")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".web-boardcast-core.bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"src_worker_js": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkwebBroadcastCore"] = self["webpackChunkwebBroadcastCore"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return __webpack_require__.e("vendors-node_modules_kalidokit_dist_index_js-node_modules_pixi_js_dist_esm_pixi_js").then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});