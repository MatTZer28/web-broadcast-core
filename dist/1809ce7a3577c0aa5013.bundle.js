/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["webBroadcastCore"] = factory();
	else
		root["webBroadcastCore"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/display/scenes-wrapper.js":
/*!***************************************!*\
  !*** ./src/display/scenes-wrapper.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScenesWrapper\": () => (/* binding */ ScenesWrapper)\n/* harmony export */ });\nconst { Scene } = __webpack_require__(/*! ../lib/scene/scene */ \"./src/lib/scene/scene.js\");\r\n\r\nclass ScenesWrapper {\r\n    constructor(WBS) {\r\n        this._WBS = WBS;\r\n        \r\n        this._scenes = [];\r\n\r\n        this._selectedSceneIndex = null;\r\n    }\r\n\r\n    createScene() {\r\n        if (this._selectedSceneIndex !== null) {\r\n            this._WBS.removeStageChild(this._scenes[this._selectedSceneIndex]);\r\n        }\r\n\r\n        const scene = new Scene(this._WBS);\r\n\r\n        this._scenes.push(scene);\r\n        this._WBS.addStageChild(scene);\r\n\r\n        this._selectedSceneIndex = this._scenes.indexOf(scene);\r\n    }\r\n\r\n    selectScene(sceneIndex) {\r\n        this._WBS.removeStageChild(this._scenes[this._selectedSceneIndex]);\r\n\r\n        this._WBS.addStageChild(this._scenes[sceneIndex]);\r\n\r\n        this._selectedSceneIndex = sceneIndex;\r\n    }\r\n\r\n    getSelectedScene() {\r\n        return this._scenes[this._selectedSceneIndex];\r\n    }\r\n\r\n    getScenesLength() {\r\n        return this._scenes.length;\r\n    }\r\n\r\n    removeScene(sceneIndex) {\r\n        this._scenes[sceneIndex].destroy();\r\n        this._scenes.splice(sceneIndex, 1);\r\n    }\r\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/display/scenes-wrapper.js?");

/***/ }),

/***/ "./src/display/sources-wrapper.js":
/*!****************************************!*\
  !*** ./src/display/sources-wrapper.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SourcesWrapper\": () => (/* binding */ SourcesWrapper)\n/* harmony export */ });\nconst { FocusBox } = __webpack_require__(/*! ../lib/utils/focus-box */ \"./src/lib/utils/focus-box.js\");\r\nconst { Virtual } = __webpack_require__(/*! ../lib/source/virtual */ \"./src/lib/source/virtual.js\");\r\nconst { Image } = __webpack_require__(/*! ../lib/source/image */ \"./src/lib/source/image.js\");\r\nconst { Video } = __webpack_require__(/*! ../lib/source/video */ \"./src/lib/source/video.js\");\r\nconst { Text } = __webpack_require__(/*! ../lib/source/text */ \"./src/lib/source/text.js\");\r\n\r\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\r\n\r\nclass SourcesWrapper {\r\n    constructor(WBS, parentScene) {\r\n        this._WBS = WBS;\r\n\r\n        this._parentScene = parentScene;\r\n\r\n        this._sources = [];\r\n\r\n        this._sourcesCreatedQueue = [];\r\n\r\n        this._addSoucreCounter = 0;\r\n\r\n        this.focusBox = new FocusBox(this._WBS);\r\n        this.focusBox.zIndex = 2;\r\n\r\n        this._parentScene.addChild(this.focusBox);\r\n\r\n        this._setMouseEventListener();\r\n    }\r\n\r\n    _setMouseEventListener() {\r\n        this._setOnMouseDownEventListener();\r\n    }\r\n\r\n    _setOnMouseDownEventListener() {\r\n        self.addEventListener(\"onmousedown\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            let isAnyFocused = false;\r\n\r\n            this._sources.forEach(source => {\r\n                if (source.isClickInsideSprite(posX, posY)) {\r\n                    isAnyFocused = true;\r\n                } else {\r\n                    source.setOnFoucsState(false);\r\n                }\r\n            });\r\n\r\n            if (!isAnyFocused) this.focusBox.resetFocusBox();\r\n        });\r\n    }\r\n\r\n    async createVirtualModel(id, url) {\r\n        this._sourceCreated = null;\r\n\r\n        const source = new Virtual(this._WBS, this, id);\r\n\r\n        await source.loadModel(url);\r\n\r\n        source.zIndex = 2;\r\n\r\n        this._sourcesCreatedQueue.push(source);\r\n    }\r\n\r\n    createImageSource(id, canvas) {\r\n        this._sourceCreated = null;\r\n\r\n        const sourceTexture = PIXI.Texture.from(canvas);\r\n\r\n        const source = new Image(this._WBS, this, id,  sourceTexture);\r\n\r\n        this._sourcesCreatedQueue.push(source);\r\n    }\r\n\r\n    createVideoSource(id, canvas) {\r\n        this._sourceCreated = null;\r\n\r\n        canvas.texture = PIXI.Texture.from(canvas);\r\n\r\n        const source = new Video(this._WBS, this, id, canvas.texture);\r\n\r\n        this._sourcesCreatedQueue.push(source);\r\n    }\r\n\r\n    createTextSource(id, text, style) {\r\n        this._sourceCreated = null;\r\n\r\n        style = style || {};\r\n\r\n        const source = new Text(this._WBS, this, id, text, style);\r\n\r\n        this._sourcesCreatedQueue.push(source);\r\n    }\r\n\r\n    addSource() {\r\n        const interval = setInterval(() => {\r\n            if (this._sourcesCreatedQueue.length > 0) {\r\n                const source = this._sourcesCreatedQueue.shift();\r\n                this._sources.push(source);\r\n                this._parentScene.addChild(source);\r\n                clearInterval(interval);\r\n            }\r\n        }, 100);\r\n    }\r\n\r\n    removeSource(id) {\r\n        this._sources.some((source) => {\r\n            if (source.id !== id) return false;\r\n\r\n            if (source instanceof Video) self.postMessage({ type: 'removeVideo', id: id });\r\n\r\n            source.destroy();\r\n            this._sources.splice(this._sources.indexOf(source), 1);\r\n\r\n            return true;\r\n        });\r\n    }\r\n\r\n    unfocusedWithout(source, state) {\r\n        this._sources.forEach(s => {\r\n            if (s !== source) {\r\n                s.setOnFoucsState(state);\r\n            }\r\n        });\r\n    }\r\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/display/sources-wrapper.js?");

/***/ }),

/***/ "./src/lib/scene/scene.js":
/*!********************************!*\
  !*** ./src/lib/scene/scene.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scene\": () => (/* binding */ Scene)\n/* harmony export */ });\nconst { SourcesWrapper } = __webpack_require__(/*! ../../display/sources-wrapper */ \"./src/display/sources-wrapper.js\");\r\n\r\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\r\n\r\nclass Scene extends PIXI.Container {\r\n    constructor(WBS) {\r\n        super();\r\n\r\n        this._WBS = WBS;\r\n\r\n        this._sourcesWrapper = new SourcesWrapper(this._WBS, this);\r\n        \r\n        this.sortableChildren = true;\r\n    }\r\n\r\n    getSourcesWrapper() {\r\n        return this._sourcesWrapper;\r\n    }\r\n\r\n    destroy() {\r\n        this.destroy({\r\n            children: true,\r\n            texture: true,\r\n            baseTexture: true\r\n        });\r\n    }\r\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/scene/scene.js?");

/***/ }),

/***/ "./src/lib/source/image.js":
/*!*********************************!*\
  !*** ./src/lib/source/image.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Image\": () => (/* binding */ Image)\n/* harmony export */ });\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\r\n\r\nclass Image extends PIXI.Container {\r\n    constructor(WBS, sourceWrapper, id, texture) {\r\n        super();\r\n\r\n        this._dragging = false;\r\n\r\n        this._focused = false;\r\n\r\n        this._WBS = WBS;\r\n\r\n        this._sourceWrapper = sourceWrapper;\r\n\r\n        this._id = id;\r\n\r\n        this._texture = texture;\r\n\r\n        this._sprite = PIXI.Sprite.from(this._texture);\r\n        this._sprite.name = 'sprite';\r\n\r\n        this._blueBox = new PIXI.Graphics();\r\n\r\n        this._initSprite();\r\n\r\n        this._setMouseEventListener();\r\n\r\n        this._addToContainer();\r\n    }\r\n\r\n    _initSprite() {\r\n        this._sprite.anchor.set(0.5);\r\n        this._sprite.x = this._WBS.appWidth / 2;\r\n        this._sprite.y = this._WBS.appHeight / 2;\r\n        this._focused = false;\r\n    }\r\n\r\n    _setMouseEventListener() {\r\n        this._setOnMouseDownEventListener();\r\n        this._setOnMouseMoveEventListener();\r\n        this._setOnMouseUpEventListener();\r\n        this._setOnMouseOverEventListener();\r\n        this._setOnMouseOutEventListener();\r\n    }\r\n\r\n    _setOnMouseDownEventListener() {\r\n        self.addEventListener(\"onmousedown\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._sprite.x - this._sprite.width / 2 + 7;\r\n            const xRight = this._sprite.x + this._sprite.width / 2 - 7;\r\n            const yTop = this._sprite.y - this._sprite.height / 2 + 7;\r\n            const yBottom = this._sprite.y + this._sprite.height / 2 - 7;\r\n\r\n            const isInX = xLeft <= posX && xRight >= posX;\r\n            const isInY = yTop <= posY && yBottom >= posY;\r\n            const isInside = isInX && isInY;\r\n\r\n            if (isInside) this._spriteOnMouseDown(posX, posY);\r\n        });\r\n    }\r\n\r\n    _setOnMouseMoveEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            this._spriteOnMouseMove(posX, posY);\r\n        });\r\n    }\r\n\r\n    _setOnMouseUpEventListener() {\r\n        self.addEventListener(\"onmouseup\", (e) => {\r\n            this._spriteOnMouseUp();\r\n        });\r\n    }\r\n\r\n    _setOnMouseOverEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._sprite.x - this._sprite.width / 2 + 7;\r\n            const xRight = this._sprite.x + this._sprite.width / 2 -7;\r\n            const yTop = this._sprite.y - this._sprite.height / 2 + 7;\r\n            const yBottom = this._sprite.y + this._sprite.height / 2 - 7;\r\n\r\n            const isInX = xLeft <= posX && xRight >= posX;\r\n            const isInY = yTop <= posY && yBottom >= posY;\r\n            const isInside = isInX && isInY;\r\n\r\n            if (isInside) this._spriteOnMouseOver();\r\n        });\r\n    }\r\n\r\n    _setOnMouseOutEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._sprite.x - this._sprite.width / 2 + 7;\r\n            const xRight = this._sprite.x + this._sprite.width / 2 - 7;\r\n            const yTop = this._sprite.y - this._sprite.height / 2 + 7;\r\n            const yBottom = this._sprite.y + this._sprite.height / 2 - 7;\r\n\r\n            const isOutX = xLeft > posX || xRight < posX;\r\n            const isOutY = yTop > posY || yBottom < posY;\r\n            const isOutside = isOutX || isOutY;\r\n\r\n            if (isOutside) this._spriteOnMouseOut();\r\n        });\r\n    }\r\n\r\n    _spriteOnMouseDown(posX, posY) {\r\n        this._blueBox.clear();\r\n        this._sourceWrapper.focusBox.setFocusedTarget(this);\r\n        this._showFocusBox();\r\n\r\n        this._WBS.setCursor(\"move\");\r\n\r\n        this._focused = true;\r\n        this._dragging = true;\r\n\r\n        this._sourceWrapper.unfocusedWithout(this, false);\r\n\r\n        this._sprite.prevInteractX = posX;\r\n        this._sprite.prevInteractY = posY;\r\n    }\r\n\r\n    setDragging(state) {\r\n        this._dragging = state;\r\n    }\r\n\r\n    _showFocusBox() {\r\n        if (!this._focused) {\r\n            let width = this._sprite.width;\r\n            let height = this._sprite.height;\r\n            let bounds = this._sprite.getBounds();\r\n            this._sourceWrapper.focusBox.drawFocusBox(bounds.x, bounds.y, width, height);\r\n        }\r\n    }\r\n\r\n    _spriteOnMouseMove(posX, posY) {\r\n        if (this._dragging) {\r\n            const deltaX = posX - this._sprite.prevInteractX;\r\n            const deltaY = posY - this._sprite.prevInteractY;\r\n\r\n            this._moveSprite(deltaX, deltaY);\r\n            this._sourceWrapper.focusBox.moveFocusBox(deltaX, deltaY);\r\n\r\n            this._sprite.prevInteractX = posX;\r\n            this._sprite.prevInteractY = posY;\r\n        }\r\n    }\r\n\r\n    _moveSprite(deltaX, deltaY) {\r\n        this._sprite.x = this._sprite.x + deltaX;\r\n        this._sprite.y = this._sprite.y + deltaY;\r\n    }\r\n\r\n    _spriteOnMouseUp() {\r\n        this._dragging = false;\r\n\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _spriteOnMouseOver() {\r\n        if (!this._focused) {\r\n            this._drawBlueBox();\r\n        }\r\n    }\r\n\r\n    _drawBlueBox() {\r\n        this._blueBox.lineStyle(4, 0x00AEB9);\r\n        this._blueBox.drawShape(this._sprite.getBounds());\r\n    }\r\n\r\n    _spriteOnMouseOut() {\r\n        if (!this._focused) {\r\n            this._blueBox.clear();\r\n        }\r\n    }\r\n\r\n    isClickInsideSprite(x, y) {\r\n        const isBiggerThanLeft = (x >= this._sprite.x - (this._sprite.width / 2) - 8);\r\n        const isSmallerThanRight = (x <= this._sprite.x + (this._sprite.width / 2) + 8);\r\n        const isInsideSpriteX = (isBiggerThanLeft && isSmallerThanRight);\r\n\r\n        const isBiggerThanTop = (y >= this._sprite.y - (this._sprite.height / 2) - 8);\r\n        const isSmallerThanBottom = (y <= this._sprite.y + (this._sprite.height / 2) + 8);\r\n        const isInsideSpriteY = (isBiggerThanTop && isSmallerThanBottom);\r\n\r\n        return (isInsideSpriteX && isInsideSpriteY);\r\n    }\r\n\r\n    _addToContainer() {\r\n        this.addChild(this._sprite);\r\n        this.addChild(this._blueBox);\r\n    }\r\n\r\n    setOnFoucsState(state) {\r\n        this._focused = state;\r\n    }\r\n\r\n    getFocusState() {\r\n        return this._focused;\r\n    }\r\n\r\n    getDraggingState() {\r\n        return this._dragging;\r\n    }\r\n\r\n    resize(x, y, width, height) {\r\n        this._sprite.x = x;\r\n        this._sprite.y = y;\r\n        this._sprite.width = width;\r\n        this._sprite.height = height;\r\n    }\r\n\r\n    destroy() {\r\n        this.destroy({\r\n            children: true,\r\n            texture: true,\r\n            baseTexture: true\r\n        });\r\n    }\r\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/source/image.js?");

/***/ }),

/***/ "./src/lib/source/text.js":
/*!********************************!*\
  !*** ./src/lib/source/text.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Text\": () => (/* binding */ Text)\n/* harmony export */ });\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\r\n\r\nclass Text extends PIXI.Container {\r\n    constructor(WBS, sourceWrapper, id, text, style) {\r\n        super();\r\n\r\n        this._dragging = false;\r\n\r\n        this._focused = false;\r\n\r\n        this._WBS = WBS;\r\n\r\n        this._sourceWrapper = sourceWrapper;\r\n\r\n        this._id = id;\r\n\r\n        this._sprite = new PIXI.Text(text, style);\r\n        this._sprite.name = 'sprite';\r\n\r\n        this._blueBox = new PIXI.Graphics();\r\n\r\n        this._resizeCounter = 0;\r\n\r\n        this._initSprite();\r\n\r\n        this._setMouseEventListener();\r\n\r\n        this._addToContainer();\r\n    }\r\n\r\n    _initSprite() {\r\n        this._sprite.anchor.set(0.5);\r\n        this._sprite.x = this._WBS.appWidth / 2;\r\n        this._sprite.y = this._WBS.appHeight / 2;\r\n        this._focused = false;\r\n    }\r\n\r\n    _setMouseEventListener() {\r\n        this._setOnMouseDownEventListener();\r\n        this._setOnMouseMoveEventListener();\r\n        this._setOnMouseUpEventListener();\r\n        this._setOnMouseOverEventListener();\r\n        this._setOnMouseOutEventListener();\r\n    }\r\n\r\n    _setOnMouseDownEventListener() {\r\n        self.addEventListener(\"onmousedown\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._sprite.x - this._sprite.width / 2 + 7;\r\n            const xRight = this._sprite.x + this._sprite.width / 2 - 7;\r\n            const yTop = this._sprite.y - this._sprite.height / 2 + 7;\r\n            const yBottom = this._sprite.y + this._sprite.height / 2 - 7;\r\n\r\n            const isInX = xLeft <= posX && xRight >= posX;\r\n            const isInY = yTop <= posY && yBottom >= posY;\r\n            const isInside = isInX && isInY;\r\n\r\n            if (isInside) this._spriteOnMouseDown(posX, posY);\r\n        });\r\n    }\r\n\r\n    _setOnMouseMoveEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            this._spriteOnMouseMove(posX, posY);\r\n        });\r\n    }\r\n\r\n    _setOnMouseUpEventListener() {\r\n        self.addEventListener(\"onmouseup\", (e) => {\r\n            this._spriteOnMouseUp();\r\n        });\r\n    }\r\n\r\n    _setOnMouseOverEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._sprite.x - this._sprite.width / 2 + 7;\r\n            const xRight = this._sprite.x + this._sprite.width / 2 - 7;\r\n            const yTop = this._sprite.y - this._sprite.height / 2 + 7;\r\n            const yBottom = this._sprite.y + this._sprite.height / 2 - 7;\r\n\r\n            const isInX = xLeft <= posX && xRight >= posX;\r\n            const isInY = yTop <= posY && yBottom >= posY;\r\n            const isInside = isInX && isInY;\r\n\r\n            if (isInside) this._spriteOnMouseOver();\r\n        });\r\n    }\r\n\r\n    _setOnMouseOutEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._sprite.x - this._sprite.width / 2 + 7;\r\n            const xRight = this._sprite.x + this._sprite.width / 2 - 7;\r\n            const yTop = this._sprite.y - this._sprite.height / 2 + 7;\r\n            const yBottom = this._sprite.y + this._sprite.height / 2 - 7;\r\n\r\n            const isOutX = xLeft > posX || xRight < posX;\r\n            const isOutY = yTop > posY || yBottom < posY;\r\n            const isOutside = isOutX || isOutY;\r\n\r\n            if (isOutside) this._spriteOnMouseOut();\r\n        });\r\n    }\r\n\r\n    _spriteOnMouseDown(posX, posY) {\r\n        this._blueBox.clear();\r\n        this._sourceWrapper.focusBox.setFocusedTarget(this);\r\n        this._showFocusBox();\r\n\r\n        this._WBS.setCursor(\"move\");\r\n\r\n        this._focused = true;\r\n        this._dragging = true;\r\n\r\n        this._sourceWrapper.unfocusedWithout(this, false);\r\n\r\n        this._sprite.prevInteractX = posX;\r\n        this._sprite.prevInteractY = posY;\r\n    }\r\n\r\n    setDragging(state) {\r\n        this._dragging = state;\r\n    }\r\n\r\n    _showFocusBox() {\r\n        if (!this._focused) {\r\n            let width = this._sprite.width;\r\n            let height = this._sprite.height;\r\n            let bounds = this._sprite.getBounds();\r\n            this._sourceWrapper.focusBox.drawFocusBox(bounds.x, bounds.y, width, height);\r\n        }\r\n    }\r\n\r\n    _spriteOnMouseMove(posX, posY) {\r\n        if (this._dragging) {\r\n            const deltaX = posX - this._sprite.prevInteractX;\r\n            const deltaY = posY - this._sprite.prevInteractY;\r\n\r\n            this._moveSprite(deltaX, deltaY);\r\n            this._sourceWrapper.focusBox.moveFocusBox(deltaX, deltaY);\r\n\r\n            this._sprite.prevInteractX = posX;\r\n            this._sprite.prevInteractY = posY;\r\n        }\r\n    }\r\n\r\n    _moveSprite(deltaX, deltaY) {\r\n        this._sprite.x = this._sprite.x + deltaX;\r\n        this._sprite.y = this._sprite.y + deltaY;\r\n    }\r\n\r\n    _spriteOnMouseUp() {\r\n        this._dragging = false;\r\n\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _spriteOnMouseOver() {\r\n        if (!this._focused) {\r\n            this._drawBlueBox();\r\n        }\r\n    }\r\n\r\n    _drawBlueBox() {\r\n        this._blueBox.lineStyle(4, 0x00AEB9);\r\n        this._blueBox.drawShape(this._sprite.getBounds());\r\n    }\r\n\r\n    _spriteOnMouseOut() {\r\n        if (!this._focused) {\r\n            this._blueBox.clear();\r\n        }\r\n    }\r\n\r\n    isClickInsideSprite(x, y) {\r\n        const isBiggerThanLeft = (x >= this._sprite.x - (this._sprite.width / 2) - 8);\r\n        const isSmallerThanRight = (x <= this._sprite.x + (this._sprite.width / 2) + 8);\r\n        const isInsideSpriteX = (isBiggerThanLeft && isSmallerThanRight);\r\n\r\n        const isBiggerThanTop = (y >= this._sprite.y - (this._sprite.height / 2) - 8);\r\n        const isSmallerThanBottom = (y <= this._sprite.y + (this._sprite.height / 2) + 8);\r\n        const isInsideSpriteY = (isBiggerThanTop && isSmallerThanBottom);\r\n\r\n        return (isInsideSpriteX && isInsideSpriteY);\r\n    }\r\n\r\n    _addToContainer() {\r\n        this.addChild(this._sprite);\r\n        this.addChild(this._blueBox);\r\n    }\r\n\r\n    setOnFoucsState(state) {\r\n        this._focused = state;\r\n    }\r\n\r\n    getFocusState() {\r\n        return this._focused;\r\n    }\r\n\r\n    getDraggingState() {\r\n        return this._dragging;\r\n    }\r\n\r\n    resize(x, y, width, height) {\r\n        this._sprite.x = x;\r\n\r\n        this._sprite.y = y;\r\n\r\n        this._sprite.width = width;\r\n\r\n        this._sprite.height = height;\r\n\r\n        this._resizeCounter++;\r\n        if (this._resizeCounter > 100) {\r\n            this._sprite.style.fontSize = height;\r\n            this._resizeCounter = 0;\r\n        }\r\n    }\r\n\r\n    destroy() {\r\n        this.destroy({\r\n            children: true,\r\n            texture: true,\r\n            baseTexture: true\r\n        });\r\n    }\r\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/source/text.js?");

/***/ }),

/***/ "./src/lib/source/video.js":
/*!*********************************!*\
  !*** ./src/lib/source/video.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Video\": () => (/* binding */ Video)\n/* harmony export */ });\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\r\n\r\nclass Video extends PIXI.Container {\r\n    constructor(WBS, sourceWrapper, id, texture) {\r\n        super();\r\n\r\n        this._dragging = false;\r\n\r\n        this._focused = false;\r\n\r\n        this._WBS = WBS;\r\n\r\n        this._sourceWrapper = sourceWrapper;\r\n\r\n        this._id = id;\r\n\r\n        this._texture = texture;\r\n\r\n        this._sprite = PIXI.Sprite.from(this._texture);\r\n        this._sprite.name = 'sprite';\r\n\r\n        this._blueBox = new PIXI.Graphics();\r\n\r\n        this._initSprite();\r\n\r\n        this._setMouseEventListener();\r\n\r\n        this._setTextureUpdateListener();\r\n        \r\n        this._addToContainer();\r\n    }\r\n\r\n    _initSprite() {\r\n        this._sprite.anchor.set(0.5);\r\n        this._sprite.x = this._WBS.appWidth / 2 + 1; // add one just to avoid the weird line (don't konw how the line appears)\r\n        this._sprite.y = this._WBS.appHeight / 2 + 1;\r\n        this._focused = false;\r\n    }\r\n\r\n    _setMouseEventListener() {\r\n        this._setOnMouseDownEventListener();\r\n        this._setOnMouseMoveEventListener();\r\n        this._setOnMouseUpEventListener();\r\n        this._setOnMouseOverEventListener();\r\n        this._setOnMouseOutEventListener();\r\n    }\r\n\r\n    _setOnMouseDownEventListener() {\r\n        self.addEventListener(\"onmousedown\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._sprite.x - this._sprite.width / 2 + 7;\r\n            const xRight = this._sprite.x + this._sprite.width / 2 - 7;\r\n            const yTop = this._sprite.y - this._sprite.height / 2 + 7;\r\n            const yBottom = this._sprite.y + this._sprite.height / 2 - 7;\r\n\r\n            const isInX = xLeft <= posX && xRight >= posX;\r\n            const isInY = yTop <= posY && yBottom >= posY;\r\n            const isInside = isInX && isInY;\r\n\r\n            if (isInside) this._spriteOnMouseDown(posX, posY);\r\n        });\r\n    }\r\n\r\n    _setOnMouseMoveEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            this._spriteOnMouseMove(posX, posY);\r\n        });\r\n    }\r\n\r\n    _setOnMouseUpEventListener() {\r\n        self.addEventListener(\"onmouseup\", (e) => {\r\n            this._spriteOnMouseUp();\r\n        });\r\n    }\r\n\r\n    _setOnMouseOverEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._sprite.x - this._sprite.width / 2 + 7;\r\n            const xRight = this._sprite.x + this._sprite.width / 2 - 7;\r\n            const yTop = this._sprite.y - this._sprite.height / 2 + 7;\r\n            const yBottom = this._sprite.y + this._sprite.height / 2 - 7;\r\n\r\n            const isInX = xLeft <= posX && xRight >= posX;\r\n            const isInY = yTop <= posY && yBottom >= posY;\r\n            const isInside = isInX && isInY;\r\n\r\n            if (isInside) this._spriteOnMouseOver();\r\n        });\r\n    }\r\n\r\n    _setOnMouseOutEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._sprite.x - this._sprite.width / 2 + 7;\r\n            const xRight = this._sprite.x + this._sprite.width / 2 - 7;\r\n            const yTop = this._sprite.y - this._sprite.height / 2 + 7;\r\n            const yBottom = this._sprite.y + this._sprite.height / 2 - 7;\r\n\r\n            const isOutX = xLeft > posX || xRight < posX;\r\n            const isOutY = yTop > posY || yBottom < posY;\r\n            const isOutside = isOutX || isOutY;\r\n\r\n            if (isOutside) this._spriteOnMouseOut();\r\n        });\r\n    }\r\n\r\n    _spriteOnMouseDown(posX, posY) {\r\n        this._blueBox.clear();\r\n        this._sourceWrapper.focusBox.setFocusedTarget(this);\r\n        this._showFocusBox();\r\n\r\n        this._WBS.setCursor(\"move\");\r\n\r\n        this._focused = true;\r\n        this._dragging = true;\r\n\r\n        this._sourceWrapper.unfocusedWithout(this, false);\r\n\r\n        this._sprite.prevInteractX = posX;\r\n        this._sprite.prevInteractY = posY;\r\n    }\r\n\r\n    setDragging(state) {\r\n        this._dragging = state;\r\n    }\r\n\r\n    _showFocusBox() {\r\n        if (!this._focused) {\r\n            let width = this._sprite.width;\r\n            let height = this._sprite.height;\r\n            let bounds = this._sprite.getBounds();\r\n            this._sourceWrapper.focusBox.drawFocusBox(bounds.x, bounds.y, width, height);\r\n        }\r\n    }\r\n\r\n    _spriteOnMouseMove(posX, posY) {\r\n        if (this._dragging) {\r\n            const deltaX = posX - this._sprite.prevInteractX;\r\n            const deltaY = posY - this._sprite.prevInteractY;\r\n\r\n            this._moveSprite(deltaX, deltaY);\r\n            this._sourceWrapper.focusBox.moveFocusBox(deltaX, deltaY);\r\n\r\n            this._sprite.prevInteractX = posX;\r\n            this._sprite.prevInteractY = posY;\r\n        }\r\n    }\r\n\r\n    _moveSprite(deltaX, deltaY) {\r\n        this._sprite.x = this._sprite.x + deltaX;\r\n        this._sprite.y = this._sprite.y + deltaY;\r\n    }\r\n\r\n    _spriteOnMouseUp() {\r\n        this._dragging = false;\r\n\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _spriteOnMouseOver() {\r\n        if (!this._focused) {\r\n            this._drawBlueBox();\r\n        }\r\n    }\r\n\r\n    _drawBlueBox() {\r\n        this._blueBox.lineStyle(4, 0x00AEB9);\r\n        this._blueBox.drawShape(this._sprite.getBounds());\r\n    }\r\n\r\n    _spriteOnMouseOut() {\r\n        if (!this._focused) {\r\n            this._blueBox.clear();\r\n        }\r\n    }\r\n\r\n    isClickInsideSprite(x, y) {\r\n        const isBiggerThanLeft = (x >= this._sprite.x - (this._sprite.width / 2) - 8);\r\n        const isSmallerThanRight = (x <= this._sprite.x + (this._sprite.width / 2) + 8);\r\n        const isInsideSpriteX = (isBiggerThanLeft && isSmallerThanRight);\r\n\r\n        const isBiggerThanTop = (y >= this._sprite.y - (this._sprite.height / 2) - 8);\r\n        const isSmallerThanBottom = (y <= this._sprite.y + (this._sprite.height / 2) + 8);\r\n        const isInsideSpriteY = (isBiggerThanTop && isSmallerThanBottom);\r\n\r\n        return (isInsideSpriteX && isInsideSpriteY);\r\n    }\r\n\r\n    _setTextureUpdateListener() {\r\n        let isSpriteSet = false;\r\n        let lastBounds = this._sprite.getBounds();\r\n\r\n        this._texture.on(\"update\", () => {\r\n            if (this._texture.width === 2 && this._texture.height === 2) {\r\n                if (isSpriteSet) return;\r\n                this._sprite.x = lastBounds.x + lastBounds.width / 2;\r\n                this._sprite.y = lastBounds.y + lastBounds.height / 2;\r\n                this._sprite.width = lastBounds.width;\r\n                this._sprite.height = lastBounds.height;\r\n                this._sprite.texture = this._createCoverTexture(lastBounds);\r\n                isSpriteSet = true;\r\n            } else {\r\n                if (isSpriteSet) this._sprite.texture = this._texture;\r\n                isSpriteSet = false;\r\n                lastBounds = this._sprite.getBounds();\r\n            }\r\n        }, this);\r\n    }\r\n\r\n    _createCoverTexture(lastBounds) {\r\n        let cover = new PIXI.Graphics();\r\n\r\n        cover.beginFill(0x5C5C5C, 0.6);\r\n        cover.drawShape(lastBounds);\r\n        cover.endFill();\r\n\r\n        return this._WBS.getApplication().renderer.generateTexture(cover);\r\n    }\r\n\r\n    _addToContainer() {\r\n        this.addChild(this._sprite);\r\n        this.addChild(this._blueBox);\r\n    }\r\n\r\n    setOnFoucsState(state) {\r\n        this._focused = state;\r\n    }\r\n\r\n    getFocusState() {\r\n        return this._focused;\r\n    }\r\n\r\n    getDraggingState() {\r\n        return this._dragging;\r\n    }\r\n\r\n    resize(x, y, width, height) {\r\n        this._sprite.x = x;\r\n        this._sprite.y = y;\r\n        this._sprite.width = width;\r\n        this._sprite.height = height;\r\n    }\r\n\r\n    destroy() {\r\n        this.destroy({\r\n            children: true,\r\n            texture: true,\r\n            baseTexture: true\r\n        });\r\n    }\r\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/source/video.js?");

/***/ }),

/***/ "./src/lib/source/virtual.js":
/*!***********************************!*\
  !*** ./src/lib/source/virtual.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Virtual\": () => (/* binding */ Virtual)\n/* harmony export */ });\n/* harmony import */ var kalidokit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kalidokit */ \"./node_modules/kalidokit/dist/index.js\");\n\r\n\r\nimportScripts(new URL(/* asset import */ __webpack_require__(/*! ../live2d/live2dcubismcore.min.js */ \"./src/lib/live2d/live2dcubismcore.min.js\"), __webpack_require__.b));\r\nimportScripts(new URL(/* asset import */ __webpack_require__(/*! ../live2d/live2d.min.js */ \"./src/lib/live2d/live2d.min.js\"), __webpack_require__.b));\r\nimportScripts(new URL(/* asset import */ __webpack_require__(/*! ../utils/face_mesh.js */ \"./src/lib/utils/face_mesh.js\"), __webpack_require__.b));\r\nimportScripts(new URL(/* asset import */ __webpack_require__(/*! ../utils/camera_utils.js */ \"./src/lib/utils/camera_utils.js\"), __webpack_require__.b));\r\n\r\nwindow.Live2DCubismCore = Live2DCubismCore;\r\n\r\nself.Live2DMotion = window.Live2DMotion;\r\nself.AMotion = window.AMotion;\r\nself.PhysicsHair = window.PhysicsHair;\r\n\r\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\r\n \r\nwindow.PIXI = PIXI;\r\n\r\nconst { Live2DModel } = __webpack_require__(/*! pixi-live2d-display */ \"./node_modules/pixi-live2d-display/lib/index.js\");\r\n\r\nclass Virtual extends PIXI.Container {\r\n    constructor(WBS, sourceWrapper, id) {\r\n        super();\r\n\r\n        this._dragging = false;\r\n\r\n        this._focused = false;\r\n\r\n        this._WBS = WBS;\r\n\r\n        this._sourceWrapper = sourceWrapper;\r\n\r\n        this._id = id;\r\n\r\n        this._blueBox = new PIXI.Graphics();\r\n    }\r\n\r\n    async loadModel(sourcePath) {\r\n        this._model = await Live2DModel.from(sourcePath, { autoInteract: false });\r\n        this._model.name = 'sprite';\r\n        this._model.internalModel.breath = null;\r\n\r\n        this._videoElement = document.createElement('video');\r\n\r\n        this._facemesh = new FaceMesh({locateFile: (file) => {\r\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\r\n        }});\r\n\r\n        this._initModel();\r\n\r\n        this._setMouseEventListener();\r\n\r\n        this._addToContainer();\r\n\r\n        this._motionTracking();\r\n    }\r\n\r\n    _initModel() {\r\n        this._model.scale.set(0.2);\r\n        this._model.anchor.set(0.5);\r\n        this._model.x = this._WBS.appWidth / 2;\r\n        this._model.y = this._WBS.appHeight / 2;\r\n        this._focused = false;\r\n    }\r\n\r\n    _setMouseEventListener() {\r\n        this._setOnMouseDownEventListener();\r\n        this._setOnMouseMoveEventListener();\r\n        this._setOnMouseUpEventListener();\r\n        this._setOnMouseOverEventListener();\r\n        this._setOnMouseOutEventListener();\r\n    }\r\n\r\n    _setOnMouseDownEventListener() {\r\n        self.addEventListener(\"onmousedown\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._model.x - this._model.width / 2 + 7;\r\n            const xRight = this._model.x + this._model.width / 2 - 7;\r\n            const yTop = this._model.y - this._model.height / 2 + 7;\r\n            const yBottom = this._model.y + this._model.height / 2 - 7;\r\n\r\n            const isInX = xLeft <= posX && xRight >= posX;\r\n            const isInY = yTop <= posY && yBottom >= posY;\r\n            const isInside = isInX && isInY;\r\n\r\n            if (isInside) this._modelOnMouseDown(posX, posY);\r\n        });\r\n    }\r\n\r\n    _setOnMouseMoveEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            this._modelOnMouseMove(posX, posY);\r\n        });\r\n    }\r\n\r\n    _setOnMouseUpEventListener() {\r\n        self.addEventListener(\"onmouseup\", (e) => {\r\n            this._modelOnMouseUp();\r\n        });\r\n    }\r\n\r\n    _setOnMouseOverEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._model.x - this._model.width / 2 + 7;\r\n            const xRight = this._model.x + this._model.width / 2 - 7;\r\n            const yTop = this._model.y - this._model.height / 2 + 7;\r\n            const yBottom = this._model.y + this._model.height / 2 - 7;\r\n\r\n            const isInX = xLeft <= posX && xRight >= posX;\r\n            const isInY = yTop <= posY && yBottom >= posY;\r\n            const isInside = isInX && isInY;\r\n\r\n            if (isInside) this._modelOnMouseOver();\r\n        });\r\n    }\r\n\r\n    _setOnMouseOutEventListener() {\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            const xLeft = this._model.x - this._model.width / 2 + 7;\r\n            const xRight = this._model.x + this._model.width / 2 - 7;\r\n            const yTop = this._model.y - this._model.height / 2 + 7;\r\n            const yBottom = this._model.y + this._model.height / 2 - 7;\r\n\r\n            const isOutX = xLeft > posX || xRight < posX;\r\n            const isOutY = yTop > posY || yBottom < posY;\r\n            const isOutside = isOutX || isOutY;\r\n\r\n            if (isOutside) this._modelOnMouseOut();\r\n        });\r\n    }\r\n\r\n    _modelOnMouseDown(posX, posY) {\r\n        this._blueBox.clear();\r\n        this._sourceWrapper.focusBox.setFocusedTarget(this);\r\n        this._showFocusBox();\r\n\r\n        this._WBS.setCursor(\"move\");\r\n\r\n        this._focused = true;\r\n        this._dragging = true;\r\n\r\n        this._sourceWrapper.unfocusedWithout(this, false);\r\n\r\n        this._model.prevInteractX = posX;\r\n        this._model.prevInteractY = posY;\r\n    }\r\n\r\n    setDragging(state) {\r\n        this._dragging = state;\r\n    }\r\n\r\n    _showFocusBox() {\r\n        if (!this._focused) {\r\n            let width = this._model.width;\r\n            let height = this._model.height;\r\n            let bounds = this._model.getBounds();\r\n            this._sourceWrapper.focusBox.drawFocusBox(bounds.x, bounds.y, width, height);\r\n        }\r\n    }\r\n\r\n    _modelOnMouseMove(posX, posY) {\r\n        if (this._dragging) {\r\n            const deltaX = posX - this._model.prevInteractX;\r\n            const deltaY = posY - this._model.prevInteractY;\r\n\r\n            this._moveModel(deltaX, deltaY);\r\n            this._sourceWrapper.focusBox.moveFocusBox(deltaX, deltaY);\r\n\r\n            this._model.prevInteractX = posX;\r\n            this._model.prevInteractY = posY;\r\n        }\r\n    }\r\n\r\n    _moveModel(deltaX, deltaY) {\r\n        this._model.x = this._model.x + deltaX;\r\n        this._model.y = this._model.y + deltaY;\r\n    }\r\n\r\n    _modelOnMouseUp() {\r\n        this._dragging = false;\r\n\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _modelOnMouseOver() {\r\n        if (!this._focused) {\r\n            this._drawBlueBox();\r\n        }\r\n    }\r\n\r\n    _drawBlueBox() {\r\n        this._blueBox.lineStyle(4, 0x00AEB9);\r\n        this._blueBox.drawShape(this._model.getBounds());\r\n    }\r\n\r\n    _modelOnMouseOut() {\r\n        if (!this._focused) {\r\n            this._blueBox.clear();\r\n        }\r\n    }\r\n\r\n    isClickInsideSprite(x, y) {\r\n        const isBiggerThanLeft = (x >= this._model.x - (this._model.width / 2) - 8);\r\n        const isSmallerThanRight = (x <= this._model.x + (this._model.width / 2) + 8);\r\n        const isInsideModelX = (isBiggerThanLeft && isSmallerThanRight);\r\n\r\n        const isBiggerThanTop = (y >= this._model.y - (this._model.height / 2) - 8);\r\n        const isSmallerThanBottom = (y <= this._model.y + (this._model.height / 2) + 8);\r\n        const isInsideModelY = (isBiggerThanTop && isSmallerThanBottom);\r\n\r\n        return (isInsideModelX && isInsideModelY);\r\n    }\r\n\r\n    _addToContainer() {\r\n        this.addChild(this._model);\r\n        this.addChild(this._blueBox);\r\n    }\r\n\r\n    _motionTracking() {\r\n        this._facemesh.setOptions({\r\n            maxNumFaces: 1,\r\n            refineLandmarks: true,\r\n            minDetectionConfidence: 0.5,\r\n            minTrackingConfidence: 0.5\r\n        });\r\n\r\n        this._facemesh.onResults((results) => {\r\n            this._animateLive2DModel(results.multiFaceLandmarks[0]);\r\n        });\r\n\r\n        this._startCamera();\r\n    }\r\n\r\n    _animateLive2DModel(points) {\r\n        if (!this._model || !points) return;\r\n\r\n        let riggedFace;\r\n\r\n        if (points) {\r\n            riggedFace = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Face.solve(points, {\r\n                runtime: \"mediapipe\",\r\n                video: this._videoElement,\r\n                smoothBlink: true,\r\n            });\r\n            this._rigFace(riggedFace, 0.5);\r\n        }\r\n    }\r\n\r\n    _rigFace(result, lerpAmount = 0.7) {\r\n        if (!this._model || !result) return;\r\n\r\n        const coreModel = this._model.internalModel.coreModel;\r\n\r\n        this._model.internalModel.motionManager.update = (...args) => {\r\n            this._model.internalModel.eyeBlink = undefined;\r\n\r\n            const EyeBallX = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.pupil.x, coreModel.getParameterValueById(\"ParamEyeBallX\"), lerpAmount);\r\n\r\n            coreModel.setParameterValueById(\"ParamEyeBallX\", EyeBallX);\r\n            coreModel.setParameterValueById(\"PARAM_EYE_BALL_X\", EyeBallX);\r\n\r\n            const EyeBallY = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.pupil.y, coreModel.getParameterValueById(\"ParamEyeBallY\"), lerpAmount);\r\n\r\n            coreModel.setParameterValueById(\"ParamEyeBallY\", EyeBallY);\r\n            coreModel.setParameterValueById(\"PARAM_EYE_BALL_y\", EyeBallY);\r\n\r\n            const angleX = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.y, coreModel.getParameterValueById(\"ParamAngleX\"), lerpAmount);\r\n\r\n            coreModel.setParameterValueById(\"ParamAngleX\", angleX);\r\n            coreModel.setParameterValueById(\"PARAM_ANGLE_X\", angleX);\r\n\r\n            const angleY = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.x, coreModel.getParameterValueById(\"ParamAngleY\"), lerpAmount);\r\n\r\n            coreModel.setParameterValueById(\"ParamAngleY\", angleY);\r\n            coreModel.setParameterValueById(\"PARAM_ANGLE_Y\", angleY);\r\n\r\n            const angleZ = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.z, coreModel.getParameterValueById(\"ParamAngleZ\"), lerpAmount);\r\n\r\n            coreModel.setParameterValueById(\"ParamAngleZ\", angleZ);\r\n            coreModel.setParameterValueById(\"PARAM_ANGLE_Z\", angleZ);\r\n\r\n            const dampener = 0.3;\r\n            const bodyAngleX = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.y * dampener, coreModel.getParameterValueById(\"ParamBodyAngleX\"), lerpAmount);\r\n\r\n            coreModel.setParameterValueById(\"ParamBodyAngleX\", bodyAngleX);\r\n            coreModel.setParameterValueById(\"PARAM_BODY_ANGLE_X\", bodyAngleX);\r\n\r\n            const bodyAngleY = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.x * dampener, coreModel.getParameterValueById(\"ParamBodyAngleY\"), lerpAmount);\r\n\r\n\r\n            coreModel.setParameterValueById(\"ParamBodyAngleY\", bodyAngleY);\r\n            coreModel.setParameterValueById(\"PARAM_BODY_ANGLE_Y\", bodyAngleY);\r\n\r\n            const bodyAngleZ = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.head.degrees.z * dampener, coreModel.getParameterValueById(\"ParamBodyAngleZ\"), lerpAmount);\r\n\r\n            coreModel.setParameterValueById(\"ParamBodyAngleZ\", bodyAngleZ);\r\n            coreModel.setParameterValueById(\"PARAM_BODY_ANGLE_Z\", bodyAngleZ);\r\n\r\n            const eyeLOpen = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.eye.l, coreModel.getParameterValueById(\"ParamEyeLOpen\"), 0.5);\r\n\r\n            coreModel.setParameterValueById(\"ParamEyeLOpen\", eyeLOpen);\r\n            coreModel.setParameterValueById(\"PARAM_EYE_L_OPEN\", eyeLOpen);\r\n\r\n            const eyeROpen = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.eye.r, coreModel.getParameterValueById(\"ParamEyeROpen\"), 0.5);\r\n\r\n\r\n            coreModel.setParameterValueById(\"ParamEyeROpen\", eyeROpen);\r\n            coreModel.setParameterValueById(\"PARAM_EYE_R_OPEN\", eyeROpen);\r\n\r\n            const mouthOpenY = kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.mouth.y, coreModel.getParameterValueById(\"ParamMouthOpenY\"), 0.3);\r\n\r\n            coreModel.setParameterValueById(\"ParamMouthOpenY\", mouthOpenY);\r\n            coreModel.setParameterValueById(\"PARAM_MOUTH_OPEN_Y\", mouthOpenY);\r\n\r\n            const mouthForm = 0.3 + kalidokit__WEBPACK_IMPORTED_MODULE_0__.Vector.lerp(result.mouth.x, coreModel.getParameterValueById(\"ParamMouthForm\"), 0.3);\r\n\r\n            coreModel.setParameterValueById(\"ParamMouthForm\", mouthForm);\r\n            coreModel.setParameterValueById(\"PARAM_MOUTH_FORM\", mouthForm);\r\n        };\r\n    }\r\n\r\n    _startCamera() {\r\n        const camera = new Camera(this._videoElement, {\r\n            onFrame: async () => {\r\n                await this._facemesh.send({ image: this._videoElement });\r\n            }\r\n        });\r\n\r\n        camera.start();\r\n    }\r\n\r\n    setOnFoucsState(state) {\r\n        this._focused = state;\r\n    }\r\n\r\n    getFocusState() {\r\n        return this._focused;\r\n    }\r\n\r\n    getDraggingState() {\r\n        return this._dragging;\r\n    }\r\n\r\n    resize(x, y, width, height) {\r\n        this._model.x = x;\r\n        this._model.y = y;\r\n        this._model.width = width;\r\n        this._model.height = height;\r\n    }\r\n\r\n    destroy() {\r\n        this.destroy({\r\n            children: true,\r\n            texture: true,\r\n            baseTexture: true\r\n        });\r\n    }\r\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/source/virtual.js?");

/***/ }),

/***/ "./src/lib/utils/focus-box.js":
/*!************************************!*\
  !*** ./src/lib/utils/focus-box.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FocusBox\": () => (/* binding */ FocusBox)\n/* harmony export */ });\nconst { Video } = __webpack_require__(/*! ../source/video */ \"./src/lib/source/video.js\");\r\n\r\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\r\n\r\nclass FocusBox extends PIXI.Container {\r\n    constructor(WBS) {\r\n        super();\r\n\r\n        this._WBS = WBS;\r\n\r\n        this._resizeing = null;\r\n\r\n        this._mouseOvering = null;\r\n\r\n        this._focusBox = {\r\n            border: new PIXI.Graphics(),\r\n            topLeft: new PIXI.Graphics(),\r\n            topMiddle: new PIXI.Graphics(),\r\n            topRight: new PIXI.Graphics(),\r\n            middleLeft: new PIXI.Graphics(),\r\n            middleRight: new PIXI.Graphics(),\r\n            bottomLeft: new PIXI.Graphics(),\r\n            bottomMiddle: new PIXI.Graphics(),\r\n            bottomRight: new PIXI.Graphics(),\r\n        };\r\n\r\n        for (const [key, value] of Object.entries(this._focusBox)) { this.addChild(value); }\r\n\r\n        this._setMouseEventListener();\r\n    }\r\n\r\n    _setMouseEventListener() {\r\n        this._setOnMouseDownEventListener();\r\n        this._setOnMouseMoveEventListener();\r\n        this._setOnMouseUpEventListener();\r\n        this._setOnMouseOverEventListener();\r\n        this._setOnMouseOutEventListener();\r\n    }\r\n\r\n    _setOnMouseDownEventListener() {\r\n        const mouseDownMap = {\r\n            topLeft: this._topLeftOnMouseDown.bind(this),\r\n            topMiddle: this._topMiddleOnMouseDown.bind(this),\r\n            topRight: this._topRightOnMouseDown.bind(this),\r\n            middleLeft: this._middleLeftOnMouseDown.bind(this),\r\n            middleRight: this._middleRightOnMouseDown.bind(this),\r\n            bottomLeft: this._bottomLeftOnMouseDown.bind(this),\r\n            bottomMiddle: this._bottomMiddleOnMouseDown.bind(this),\r\n            bottomRight: this._bottomRightOnMouseDown.bind(this),\r\n        };\r\n\r\n        self.addEventListener(\"onmousedown\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            for (const key in this._focusBox) {\r\n                if (key === 'border') continue;\r\n\r\n                const xLeft = this._focusBox[key].getBounds().x;\r\n                const xRight = this._focusBox[key].getBounds().x + this._focusBox[key].getBounds().width;\r\n                const yTop = this._focusBox[key].getBounds().y;\r\n                const yBottom = this._focusBox[key].getBounds().y + this._focusBox[key].getBounds().height;\r\n\r\n                const isInX = xLeft <= posX && xRight >= posX;\r\n                const isInY = yTop <= posY && yBottom >= posY;\r\n                const isInside = isInX && isInY;\r\n\r\n                if (isInside) mouseDownMap[key](posX, posY);\r\n            }\r\n        });\r\n    }\r\n\r\n    _setOnMouseMoveEventListener() {\r\n        const mouseMoveMap = {\r\n            topLeft: this._topLeftOnMouseMove.bind(this),\r\n            topMiddle: this._topMiddleOnMouseMove.bind(this),\r\n            topRight: this._topRightOnMouseMove.bind(this),\r\n            middleLeft: this._middleLeftOnMouseMove.bind(this),\r\n            middleRight: this._middleRightOnMouseMove.bind(this),\r\n            bottomLeft: this._bottomLeftOnMouseMove.bind(this),\r\n            bottomMiddle: this._bottomMiddleOnMouseMove.bind(this),\r\n            bottomRight: this._bottomRightOnMouseMove.bind(this),\r\n        };\r\n\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            if (this._resizeing !== null) mouseMoveMap[this._resizeing](posX, posY);\r\n        });\r\n    }\r\n\r\n    _setOnMouseUpEventListener() {\r\n        self.addEventListener(\"onmouseup\", (e) => {\r\n            this._resizeing = null;\r\n        });\r\n    }\r\n\r\n    _setOnMouseOverEventListener() {\r\n        const mouseOverMap = {\r\n            topLeft: this._topLeftOnMouseOver.bind(this),\r\n            topMiddle: this._topMiddleOnMouseOver.bind(this),\r\n            topRight: this._topRightOnMouseOver.bind(this),\r\n            middleLeft: this._middleLeftOnMouseOver.bind(this),\r\n            middleRight: this._middleRightOnMouseOver.bind(this),\r\n            bottomLeft: this._bottomLeftOnMouseOver.bind(this),\r\n            bottomMiddle: this._bottomMiddleOnMouseOver.bind(this),\r\n            bottomRight: this._bottomRightOnMouseOver.bind(this),\r\n        };\r\n\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            for (const key in this._focusBox) {\r\n                if (key === 'border') continue;\r\n\r\n                const xLeft = this._focusBox[key].getBounds().x;\r\n                const xRight = this._focusBox[key].getBounds().x + this._focusBox[key].getBounds().width;\r\n                const yTop = this._focusBox[key].getBounds().y;\r\n                const yBottom = this._focusBox[key].getBounds().y + this._focusBox[key].getBounds().height;\r\n\r\n                const isInX = xLeft <= posX && xRight >= posX;\r\n                const isInY = yTop <= posY && yBottom >= posY;\r\n                const isInside = isInX && isInY;\r\n\r\n                if (isInside) mouseOverMap[key]();\r\n            }\r\n        });\r\n    }\r\n\r\n    _setOnMouseOutEventListener() {\r\n        const mouseOutMap = {\r\n            topLeft: this._topLeftOnMouseOut.bind(this),\r\n            topMiddle: this._topMiddleOnMouseOut.bind(this),\r\n            topRight: this._topRightOnMouseOut.bind(this),\r\n            middleLeft: this._middleLeftOnMouseOut.bind(this),\r\n            middleRight: this._middleRightOnMouseOut.bind(this),\r\n            bottomLeft: this._bottomLeftOnMouseOut.bind(this),\r\n            bottomMiddle: this._bottomMiddleOnMouseOut.bind(this),\r\n            bottomRight: this._bottomRightOnMouseOut.bind(this),\r\n        };\r\n\r\n        self.addEventListener(\"onmousemove\", (e) => {\r\n            const posX = e.detail.position.x;\r\n            const posY = e.detail.position.y;\r\n\r\n            if (this._mouseOvering !== null) {\r\n                const xLeft = this._focusBox[this._mouseOvering].getBounds().x;\r\n                const xRight = this._focusBox[this._mouseOvering].getBounds().x + this._focusBox[this._mouseOvering].getBounds().width;\r\n                const yTop = this._focusBox[this._mouseOvering].getBounds().y;\r\n                const yBottom = this._focusBox[this._mouseOvering].getBounds().y + this._focusBox[this._mouseOvering].getBounds().height;\r\n\r\n                const isOutX = xLeft > posX || xRight < posX;\r\n                const isOutY = yTop > posY || yBottom < posY;\r\n                const isOutside = isOutX || isOutY;\r\n\r\n                if (isOutside) mouseOutMap[this._mouseOvering]();\r\n            }\r\n        });\r\n    }\r\n\r\n    _topLeftOnMouseDown(posX, posY) {\r\n        this._focusedTarget.setDragging(false);\r\n        this._resizeing = 'topLeft';\r\n        this._focusBox[\"border\"].prevInteractX = posX;\r\n        this._focusBox[\"border\"].prevInteractY = posY;\r\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\r\n    }\r\n\r\n    _topLeftOnMouseMove(posX, posY) {\r\n        if (posX < 0 || posX > this._WBS.appWidth) return;\r\n        if (posY > this._WBS.appHeight || posY < 0) return;\r\n        if (this._resizeing === 'topLeft') {\r\n            const rightX = this._focusBox[\"border\"].prevInteractX + this._focusBox[\"border\"].originWidth;\r\n            const bottomY = this._focusBox[\"border\"].prevInteractY + this._focusBox[\"border\"].originHeight;\r\n\r\n            const isCurrXTooOver = posX > rightX;\r\n            const isCurrYTooOver = posY > bottomY;\r\n\r\n            const deltaX = this._focusBox[\"border\"].prevInteractX - posX;\r\n            const deltaY = this._focusBox[\"border\"].prevInteractY - posY;\r\n\r\n            const width = this._focusBox[\"border\"].originWidth;\r\n            const height = this._focusBox[\"border\"].originHeight;\r\n\r\n            if (isCurrXTooOver && isCurrYTooOver) {\r\n                this.drawFocusBox(rightX, bottomY, 1, 1);\r\n\r\n                const resizeX = rightX;\r\n                const resizeY = bottomY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n                return;\r\n            }\r\n\r\n            if (isCurrXTooOver) {\r\n                this.drawFocusBox(rightX, posY, 1, height + deltaY);\r\n\r\n                const resizeX = rightX;\r\n                const resizeY = posY + this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            } else if (isCurrYTooOver) {\r\n                this.drawFocusBox(posX, bottomY, width + deltaX, 1);\r\n\r\n                const resizeX = posX + this._focusBox[\"border\"].width / 2;\r\n                const resizeY = bottomY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            } else {\r\n                this.drawFocusBox(posX, posY, width + deltaX, height + deltaY);\r\n\r\n                const resizeX = posX + this._focusBox[\"border\"].width / 2;\r\n                const resizeY = posY + this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            }\r\n        }\r\n    }\r\n\r\n    _topLeftOnMouseOver() {\r\n        this._mouseOvering = 'topLeft';\r\n        this._WBS.setCursor(\"nwse-resize\");\r\n    }\r\n\r\n    _topLeftOnMouseOut() {\r\n        this._mouseOvering = null;\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _topMiddleOnMouseDown(posX, posY) {\r\n        this._focusedTarget.setDragging(false);\r\n        this._resizeing = 'topMiddle';\r\n        this._focusBox[\"border\"].prevInteractY = posY;\r\n        this._focusBox[\"border\"].originX = posX - this._focusBox[\"border\"].width / 2;\r\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\r\n    }\r\n\r\n    _topMiddleOnMouseMove(posX, posY) {\r\n        if (posY > this._WBS.appHeight || posY < 0) return;\r\n        if (this._resizeing === 'topMiddle') {\r\n            const bottomY = this._focusBox[\"border\"].prevInteractY + this._focusBox[\"border\"].originHeight;\r\n\r\n            const isCurrYTooOver = posY > bottomY;\r\n\r\n            const deltaY = this._focusBox[\"border\"].prevInteractY - posY;\r\n\r\n            const width = this._focusBox[\"border\"].originWidth;\r\n            const height = this._focusBox[\"border\"].originHeight;\r\n\r\n            if (isCurrYTooOver) {\r\n                this.drawFocusBox(this._focusBox[\"border\"].originX, bottomY, width, 1);\r\n\r\n                const resizeX = this._focusBox[\"border\"].originX + this._focusBox[\"border\"].width / 2;\r\n                const resizeY = bottomY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, width, this._focusBox[\"border\"].height);\r\n                return;\r\n            }\r\n\r\n            this.drawFocusBox(this._focusBox[\"border\"].originX, posY, width, height + deltaY);\r\n\r\n            const resizeX = this._focusBox[\"border\"].originX + this._focusBox[\"border\"].width / 2;\r\n            const resizeY = posY + this._focusBox[\"border\"].height / 2;\r\n\r\n            this._focusedTarget.resize(resizeX, resizeY, width, this._focusBox[\"border\"].height);\r\n        }\r\n    }\r\n\r\n    _topMiddleOnMouseOver() {\r\n        this._mouseOvering = 'topMiddle';\r\n        this._WBS.setCursor(\"ns-resize\");\r\n    }\r\n\r\n    _topMiddleOnMouseOut() {\r\n        this._mouseOvering = null;\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _topRightOnMouseDown(posX, posY) {\r\n        this._focusedTarget.setDragging(false);\r\n        this._resizeing = 'topRight';\r\n        this._focusBox[\"border\"].prevInteractX = posX;\r\n        this._focusBox[\"border\"].prevInteractY = posY;\r\n        this._focusBox[\"border\"].originX = posX - this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\r\n    }\r\n\r\n    _topRightOnMouseMove(posX, posY) {\r\n        if (posX < 0 || posX > this._WBS.appWidth) return;\r\n        if (posY > this._WBS.appHeight || posY < 0) return;\r\n        if (this._resizeing === 'topRight') {\r\n            const leftX = this._focusBox[\"border\"].originX;\r\n            const bottomY = this._focusBox[\"border\"].prevInteractY + this._focusBox[\"border\"].originHeight;\r\n\r\n            const isCurrXTooOver = posX < leftX;\r\n            const isCurrYTooOver = posY > bottomY;\r\n\r\n            const deltaX = posX - this._focusBox[\"border\"].prevInteractX;\r\n            const deltaY = this._focusBox[\"border\"].prevInteractY - posY;\r\n\r\n            const width = this._focusBox[\"border\"].originWidth;\r\n            const height = this._focusBox[\"border\"].originHeight;\r\n\r\n            if (isCurrXTooOver && isCurrYTooOver) {\r\n                this.drawFocusBox(leftX, bottomY, 1, 1);\r\n\r\n                const resizeX = leftX;\r\n                const resizeY = bottomY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n                return;\r\n            }\r\n\r\n            if (isCurrXTooOver) {\r\n                this.drawFocusBox(leftX, posY, 1, height + deltaY);\r\n\r\n                const resizeX = leftX;\r\n                const resizeY = posY + this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            } else if (isCurrYTooOver) {\r\n                this.drawFocusBox(this._focusBox[\"border\"].originX, bottomY, width + deltaX, 1);\r\n\r\n                const resizeX = posX - this._focusBox[\"border\"].width / 2;\r\n                const resizeY = bottomY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            } else {\r\n                this.drawFocusBox(this._focusBox[\"border\"].originX, posY, width + deltaX, height + deltaY);\r\n\r\n                const resizeX = posX - this._focusBox[\"border\"].width / 2;\r\n                const resizeY = posY + this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            }\r\n        }\r\n    }\r\n\r\n    _topRightOnMouseOver() {\r\n        this._mouseOvering = 'topRight';\r\n        this._WBS.setCursor(\"ne-resize\");\r\n    }\r\n\r\n    _topRightOnMouseOut() {\r\n        this._mouseOvering = null;\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _middleLeftOnMouseDown(posX, posY) {\r\n        this._focusedTarget.setDragging(false);\r\n        this._resizeing = 'middleLeft';\r\n        this._focusBox[\"border\"].prevInteractX = posX;\r\n        this._focusBox[\"border\"].originY = posY - this._focusBox[\"border\"].height / 2;\r\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\r\n    }\r\n\r\n    _middleLeftOnMouseMove(posX, posY) {\r\n        if (posX < 0 || posX > this._WBS.appWidth) return;\r\n        if (this._resizeing === 'middleLeft') {\r\n            const rightX = this._focusBox[\"border\"].prevInteractX + this._focusBox[\"border\"].originWidth;\r\n\r\n            const isCurrXTooOver = posX > rightX;\r\n\r\n            const deltaX = this._focusBox[\"border\"].prevInteractX - posX;\r\n\r\n            const width = this._focusBox[\"border\"].originWidth;\r\n            const height = this._focusBox[\"border\"].originHeight;\r\n\r\n            if (isCurrXTooOver) {\r\n                this.drawFocusBox(rightX, this._focusBox[\"border\"].originY, 1, height);\r\n\r\n                const resizeX = rightX;\r\n                const resizeY = this._focusBox[\"border\"].originY + this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n                return;\r\n            }\r\n\r\n            this.drawFocusBox(posX, this._focusBox[\"border\"].originY, width + deltaX, height);\r\n\r\n            const resizeX = posX + this._focusBox[\"border\"].width / 2;\r\n            const resizeY = this._focusBox[\"border\"].originY + this._focusBox[\"border\"].height / 2;\r\n\r\n            this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n        }\r\n    }\r\n\r\n    _middleLeftOnMouseOver() {\r\n        this._mouseOvering = 'middleLeft';\r\n        this._WBS.setCursor(\"w-resize\");\r\n    }\r\n\r\n    _middleLeftOnMouseOut() {\r\n        this._mouseOvering = null;\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _middleRightOnMouseDown(posX, posY) {\r\n        this._focusedTarget.setDragging(false);\r\n        this._resizeing = 'middleRight';\r\n        this._focusBox[\"border\"].prevInteractX = posX;\r\n        this._focusBox[\"border\"].originX = posX - this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originY = posY - this._focusBox[\"border\"].height / 2;\r\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\r\n    }\r\n\r\n    _middleRightOnMouseMove(posX, posY) {\r\n        if (posX < 0 || posX > this._WBS.appWidth) return;\r\n        if (this._resizeing === 'middleRight') {\r\n            const leftX = this._focusBox[\"border\"].originX;\r\n\r\n            const isCurrXTooOver = posX < leftX;\r\n\r\n            const deltaX = posX - this._focusBox[\"border\"].prevInteractX;\r\n\r\n            const width = this._focusBox[\"border\"].originWidth;\r\n            const height = this._focusBox[\"border\"].originHeight;\r\n\r\n            if (isCurrXTooOver) {\r\n                this.drawFocusBox(leftX, this._focusBox[\"border\"].originY, 1, height);\r\n\r\n                const resizeX = leftX;\r\n                const resizeY = this._focusBox[\"border\"].originY + this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n                return;\r\n            }\r\n\r\n            this.drawFocusBox(this._focusBox[\"border\"].originX, this._focusBox[\"border\"].originY, width + deltaX, height);\r\n\r\n            const resizeX = posX - this._focusBox[\"border\"].width / 2;\r\n            const resizeY = this._focusBox[\"border\"].originY + this._focusBox[\"border\"].height / 2;\r\n\r\n            this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n        }\r\n    }\r\n\r\n    _middleRightOnMouseOver() {\r\n        this._mouseOvering = 'middleRight';\r\n        this._WBS.setCursor(\"e-resize\");\r\n    }\r\n\r\n    _middleRightOnMouseOut() {\r\n        this._mouseOvering = null;\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _bottomLeftOnMouseDown(posX, posY) {\r\n        this._focusedTarget.setDragging(false);\r\n        this._resizeing = 'bottomLeft';\r\n        this._focusBox[\"border\"].prevInteractX = posX;\r\n        this._focusBox[\"border\"].prevInteractY = posY;\r\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\r\n    }\r\n\r\n    _bottomLeftOnMouseMove(posX, posY) {\r\n        if (posX < 0 || posX > this._WBS.appWidth) return;\r\n        if (posY > this._WBS.appHeight || posY < 0) return;\r\n        if (this._resizeing === 'bottomLeft') {\r\n            const rightX = this._focusBox[\"border\"].prevInteractX + this._focusBox[\"border\"].originWidth;\r\n            const topY = this._focusBox[\"border\"].prevInteractY - this._focusBox[\"border\"].originHeight;\r\n\r\n            const isCurrXTooOver = posX > rightX;\r\n            const isCurrYTooOver = posY < topY;\r\n\r\n            const deltaX = this._focusBox[\"border\"].prevInteractX - posX;\r\n            const deltaY = posY - this._focusBox[\"border\"].prevInteractY;\r\n\r\n            const width = this._focusBox[\"border\"].originWidth;\r\n            const height = this._focusBox[\"border\"].originHeight;\r\n\r\n            if (isCurrXTooOver && isCurrYTooOver) {\r\n                this.drawFocusBox(rightX, topY, 1, 1);\r\n\r\n                const resizeX = rightX;\r\n                const resizeY = topY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n                return;\r\n            }\r\n\r\n            if (isCurrXTooOver) {\r\n                this.drawFocusBox(rightX, posY - this._focusBox[\"border\"].height, 1, height + deltaY);\r\n\r\n                const resizeX = rightX;\r\n                const resizeY = posY - this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            } else if (isCurrYTooOver) {\r\n                this.drawFocusBox(posX, topY, width + deltaX, 1);\r\n\r\n                const resizeX = posX + this._focusBox[\"border\"].width / 2;\r\n                const resizeY = topY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            } else {\r\n                this.drawFocusBox(posX, posY - this._focusBox[\"border\"].height, width + deltaX, height + deltaY);\r\n\r\n                const resizeX = posX + this._focusBox[\"border\"].width / 2;\r\n                const resizeY = posY - this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            }\r\n        }\r\n    }\r\n\r\n    _bottomLeftOnMouseOver() {\r\n        this._mouseOvering = 'bottomLeft';\r\n        this._WBS.setCursor(\"ne-resize\");\r\n    }\r\n\r\n    _bottomLeftOnMouseOut() {\r\n        this._mouseOvering = null;\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _bottomMiddleOnMouseDown(posX, posY) {\r\n        this._focusedTarget.setDragging(false);\r\n        this._resizeing = 'bottomMiddle';\r\n        this._focusBox[\"border\"].prevInteractY = posY;\r\n        this._focusBox[\"border\"].originX = posX - this._focusBox[\"border\"].width / 2;\r\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\r\n    }\r\n\r\n    _bottomMiddleOnMouseMove(posX, posY) {\r\n        if (posY > this._WBS.appHeight || posY < 0) return;\r\n        if (this._resizeing === 'bottomMiddle') {\r\n            const topY = this._focusBox[\"border\"].prevInteractY - this._focusBox[\"border\"].originHeight;\r\n\r\n            const isCurrYTooOver = posY < topY;\r\n\r\n            const deltaY = posY - this._focusBox[\"border\"].prevInteractY;\r\n\r\n            const width = this._focusBox[\"border\"].originWidth;\r\n            const height = this._focusBox[\"border\"].originHeight;\r\n\r\n            if (isCurrYTooOver) {\r\n                this.drawFocusBox(this._focusBox[\"border\"].originX, topY, width, 1);\r\n\r\n                const resizeX = this._focusBox[\"border\"].originX + this._focusBox[\"border\"].width / 2;\r\n                const resizeY = topY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, width, this._focusBox[\"border\"].height);\r\n                return;\r\n            }\r\n\r\n            this.drawFocusBox(this._focusBox[\"border\"].originX, posY - this._focusBox[\"border\"].height, width, height + deltaY);\r\n\r\n            const resizeX = this._focusBox[\"border\"].originX + this._focusBox[\"border\"].width / 2;\r\n            const resizeY = posY - this._focusBox[\"border\"].height / 2;\r\n\r\n            this._focusedTarget.resize(resizeX, resizeY, width, this._focusBox[\"border\"].height);\r\n        }\r\n    }\r\n\r\n    _bottomMiddleOnMouseOver() {\r\n        this._mouseOvering = 'bottomMiddle';\r\n        this._WBS.setCursor(\"s-resize\");\r\n    }\r\n\r\n    _bottomMiddleOnMouseOut() {\r\n        this._mouseOvering = null;\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    _bottomRightOnMouseDown(posX, posY) {\r\n        this._focusedTarget.setDragging(false);\r\n        this._resizeing = 'bottomRight';\r\n        this._focusBox[\"border\"].prevInteractX = posX;\r\n        this._focusBox[\"border\"].prevInteractY = posY;\r\n        this._focusBox[\"border\"].originX = posX - this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originWidth = this._focusBox[\"border\"].width;\r\n        this._focusBox[\"border\"].originHeight = this._focusBox[\"border\"].height;\r\n    }\r\n\r\n    _bottomRightOnMouseMove(posX, posY) {\r\n        if (posX < 0 || posX > this._WBS.appWidth) return;\r\n        if (posY > this._WBS.appHeight || posY < 0) return;\r\n        if (this._resizeing === 'bottomRight') {\r\n            const leftX = this._focusBox[\"border\"].originX;\r\n            const topY = this._focusBox[\"border\"].prevInteractY - this._focusBox[\"border\"].originHeight;\r\n\r\n            const isCurrXTooOver = posX < leftX;\r\n            const isCurrYTooOver = posY < topY;\r\n\r\n            const deltaX = posX - this._focusBox[\"border\"].prevInteractX;\r\n            const deltaY = posY - this._focusBox[\"border\"].prevInteractY;\r\n\r\n            const width = this._focusBox[\"border\"].originWidth;\r\n            const height = this._focusBox[\"border\"].originHeight;\r\n\r\n            if (isCurrXTooOver && isCurrYTooOver) {\r\n                this.drawFocusBox(leftX, topY, 1, 1);\r\n\r\n                const resizeX = leftX;\r\n                const resizeY = topY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n                return;\r\n            }\r\n\r\n            if (isCurrXTooOver) {\r\n                this.drawFocusBox(leftX, posY - this._focusBox[\"border\"].height, 1, height + deltaY);\r\n\r\n                const resizeX = leftX;\r\n                const resizeY = posY - this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            } else if (isCurrYTooOver) {\r\n                this.drawFocusBox(this._focusBox[\"border\"].originX, topY, width + deltaX, 1);\r\n\r\n                const resizeX = posX - this._focusBox[\"border\"].width / 2;\r\n                const resizeY = topY;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            } else {\r\n                this.drawFocusBox(this._focusBox[\"border\"].originX, posY - this._focusBox[\"border\"].height, width + deltaX, height + deltaY);\r\n\r\n                const resizeX = posX - this._focusBox[\"border\"].width / 2;\r\n                const resizeY = posY - this._focusBox[\"border\"].height / 2;\r\n\r\n                this._focusedTarget.resize(resizeX, resizeY, this._focusBox[\"border\"].width, this._focusBox[\"border\"].height);\r\n            }\r\n        }\r\n    }\r\n\r\n    _bottomRightOnMouseOver() {\r\n        this._mouseOvering = 'bottomRight';\r\n        this._WBS.setCursor(\"se-resize\");\r\n    }\r\n\r\n    _bottomRightOnMouseOut() {\r\n        this._mouseOvering = null;\r\n        this._WBS.setCursor(\"auto\");\r\n    }\r\n\r\n    getFocusBox() {\r\n        return this._focusBox;\r\n    }\r\n\r\n    setFocusedTarget(focusedTarget) {\r\n        this._focusedTarget = focusedTarget;\r\n        if (this._focusedTarget instanceof Video) this._onFocusTargetUpdate();\r\n    }\r\n\r\n    _onFocusTargetUpdate() {\r\n        let preWidth = this._focusedTarget.getChildByName('sprite').width;\r\n        let preHeight = this._focusedTarget.getChildByName('sprite').height;\r\n\r\n        this._focusedTarget.getChildByName('sprite').texture.on(\"update\", () => {\r\n            if (this._resizeing !== null || !this._focusedTarget.getFocusState() || this._focusedTarget.getDraggingState()) return;\r\n\r\n            const width = this._focusedTarget.getChildByName('sprite').width;\r\n            const height = this._focusedTarget.getChildByName('sprite').height;\r\n            const x = this._focusedTarget.getChildByName('sprite').x - width / 2;\r\n            const y = this._focusedTarget.getChildByName('sprite').y - height / 2;\r\n\r\n            if (width !== preWidth || height !== preHeight) this.drawFocusBox(x, y, width, height);\r\n\r\n            preWidth = this._focusedTarget.getChildByName('sprite').width;\r\n            preHeight = this._focusedTarget.getChildByName('sprite').height;\r\n        }, this);\r\n    }\r\n\r\n    drawFocusBox(x, y, width, height) {\r\n        this.resetFocusBox();\r\n\r\n        this._focusBox.border.lineStyle(4, 0xEB4034);\r\n        this._focusBox.border.drawRect(x, y, width, height);\r\n\r\n        const dotWidth = 15;\r\n        const dotHeight = 15;\r\n\r\n        const first = [\"top\", \"middle\", \"bottom\"];\r\n        const last = [\"Left\", \"Middle\", \"Right\"];\r\n        let firstPos = 0;\r\n        let lastPos = 0;\r\n\r\n        const leftMiddleRightPosX = [\r\n            x - (dotWidth / 2),\r\n            x + (width / 2) - (dotWidth / 2),\r\n            x + width - (dotWidth / 2),\r\n        ];\r\n        const topMiddleBottomPosY = [\r\n            y - (dotHeight / 2),\r\n            y + (height / 2) - (dotHeight / 2),\r\n            y + height - (dotHeight / 2),\r\n        ];\r\n\r\n        topMiddleBottomPosY.forEach(posY => {\r\n            lastPos = 0;\r\n            leftMiddleRightPosX.forEach(posX => {\r\n                if (!(firstPos === 1 && lastPos === 1)) {\r\n                    this._focusBox[first[firstPos] + last[lastPos]].beginFill(0xEB4034);\r\n                    this._focusBox[first[firstPos] + last[lastPos]].drawRect(posX, posY, dotWidth, dotHeight);\r\n                    this._focusBox[first[firstPos] + last[lastPos]].endFill();\r\n                }\r\n                lastPos = lastPos + 1;\r\n            })\r\n            firstPos = firstPos + 1;\r\n        })\r\n    }\r\n\r\n    resetFocusBox() {\r\n        for (const [key, value] of Object.entries(this._focusBox)) {\r\n            this._focusBox[key].clear();\r\n            this._focusBox[key].x = 0;\r\n            this._focusBox[key].y = 0;\r\n        }\r\n    }\r\n\r\n    moveFocusBox(deltaX, deltaY) {\r\n        for (const [key, value] of Object.entries(this._focusBox)) {\r\n            this._focusBox[key].x = this._focusBox[key].x + deltaX;\r\n            this._focusBox[key].y = this._focusBox[key].y + deltaY;\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/utils/focus-box.js?");

/***/ }),

/***/ "./src/lib/web-brocast-system.js":
/*!***************************************!*\
  !*** ./src/lib/web-brocast-system.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebBroadcastSystem\": () => (/* binding */ WebBroadcastSystem)\n/* harmony export */ });\nconst { ScenesWrapper } = __webpack_require__(/*! ../display/scenes-wrapper */ \"./src/display/scenes-wrapper.js\");\r\n\r\nconst PIXI = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/esm/pixi.js\");\r\n\r\nclass WebBroadcastSystem {\r\n    constructor(canvas, appWidth, appHeight, fps) {\r\n        this.canvas = canvas;\r\n\r\n        this.appWidth = appWidth;\r\n\r\n        this.appHeight = appHeight;\r\n\r\n        this.fps = fps;\r\n\r\n        this._pixiApp = this._createApplication();\r\n\r\n        this.background = new PIXI.Sprite(PIXI.Texture.WHITE);\r\n        this._initBackground();\r\n\r\n        this._scenesWrapper = new ScenesWrapper(this);\r\n    }\r\n\r\n    _createApplication() {\r\n        return new PIXI.Application({\r\n            width: this.appWidth,\r\n            height: this.appHeight,\r\n            backgroundColor: 0xffffff,\r\n            clearBeforeRender: true,\r\n            backgroundAlpha: 0,\r\n            antialias: true,\r\n            view: this.canvas\r\n        });\r\n    }\r\n\r\n    _initBackground() {\r\n        this.background.width = this.appWidth;\r\n        this.background.height = this.appHeight;\r\n        this.background.tint = 0xD7D7D6;\r\n        this._pixiApp.stage.addChild(this.background);\r\n    }\r\n\r\n    getApplication() {\r\n        return this._pixiApp;\r\n    }\r\n\r\n    getScenesWrapper() {\r\n        return this._scenesWrapper;\r\n    }\r\n\r\n    addStageChild(child) {\r\n        this._pixiApp.stage.addChild(child);\r\n    }\r\n\r\n    removeStageChild(child) {\r\n        this._pixiApp.stage.removeChild(child);\r\n    }\r\n\r\n    setCursor(mode) {\r\n        self.postMessage({ type: 'setCursor', mode: mode });\r\n    }\r\n}\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/web-brocast-system.js?");

/***/ }),

/***/ "./src/worker.js":
/*!***********************!*\
  !*** ./src/worker.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("self.HTMLVideoElement = function HTMLVideoElement() { };\r\n\r\nself.HTMLImageElement = function HTMLImageElement() { };\r\n\r\nself.HTMLCanvasElement = self.OffscreenCanvas;\r\n\r\nclass Image {\r\n    constructor() {\r\n        this.src = '';\r\n    }\r\n}\r\n\r\nself.Image = Image;\r\n\r\nself.document = {\r\n    createElement(type) {\r\n        if (type === 'canvas') {\r\n            return new OffscreenCanvas(0, 0);\r\n        }\r\n\r\n        return {\r\n            style: {}\r\n        };\r\n    },\r\n\r\n    addEventListener() { }\r\n};\r\n\r\nself.window = {\r\n    console: self.console,\r\n\r\n    addEventListener() { },\r\n\r\n    removeEventListener() { },\r\n\r\n    navigator: {},\r\n\r\n    location: {\r\n        port: 0\r\n    },\r\n\r\n    document: self.document,\r\n\r\n    WebGLRenderingContext: self.WebGL2RenderingContext || self.WebGL2RenderingContext,\r\n\r\n    requestAnimationFrame: self.requestAnimationFrame.bind(self)\r\n};\r\n\r\nconst { WebBroadcastSystem } = __webpack_require__(/*! ./lib/web-brocast-system */ \"./src/lib/web-brocast-system.js\");\r\n\r\nlet WBS;\r\n\r\nlet videoOffScreens = {};\r\n\r\nself.addEventListener('message', (e) => {\r\n    let mouseDownEvent = null;\r\n    let mouseMoveEvent = null;\r\n    let mouseUpEvent = null;\r\n\r\n    switch (e.data.type) {\r\n        case 'init':\r\n            window.location.port = e.data.location;\r\n            WBS = new WebBroadcastSystem(e.data.canvas, e.data.width, e.data.height, e.data.fps);\r\n            break;\r\n        case 'mouseDown':\r\n            mouseDownEvent = new CustomEvent('onmousedown', { detail: { position: { x: e.data.posX, y: e.data.posY } } });\r\n            self.dispatchEvent(mouseDownEvent);\r\n            break;\r\n        case 'mouseMove':\r\n            mouseMoveEvent = new CustomEvent('onmousemove', { detail: { position: { x: e.data.posX, y: e.data.posY } } });\r\n            self.dispatchEvent(mouseMoveEvent);\r\n            break;\r\n        case 'mouseUp':\r\n            mouseUpEvent = new CustomEvent('onmouseup', { detail: { position: { x: e.data.posX, y: e.data.posY } } });\r\n            self.dispatchEvent(mouseUpEvent);\r\n            break;\r\n        case 'createScene':\r\n            WBS.getScenesWrapper().createScene();\r\n            break;\r\n        case 'removeScene':\r\n            WBS.getScenesWrapper().removeScene(e.data.sceneIndex);\r\n            break;\r\n        case 'selectScene':\r\n            WBS.getScenesWrapper().selectScene(e.data.sceneIndex);\r\n            break;\r\n        case 'createVirtualModel':\r\n            WBS.getScenesWrapper().getSelectedScene().getSourcesWrapper().createVirtualModel(e.data.id, e.data.url);\r\n            break;\r\n        case 'createImageSource':\r\n            const imageOffscreen = new OffscreenCanvas(e.data.bitmap.width, e.data.bitmap.height);\r\n\r\n            imageOffscreen.getContext('bitmaprenderer').transferFromImageBitmap(e.data.bitmap);\r\n\r\n            WBS.getScenesWrapper().getSelectedScene().getSourcesWrapper().createImageSource(e.data.id, imageOffscreen);\r\n            break;\r\n        case 'createVideoSource':\r\n            videoOffScreens[e.data.id] = new OffscreenCanvas(0, 0);\r\n\r\n            WBS.getScenesWrapper().getSelectedScene().getSourcesWrapper().createVideoSource(e.data.id, videoOffScreens[e.data.id]);\r\n            break;\r\n        case 'updateVideoSource':\r\n            videoOffScreens[e.data.id].width = e.data.bitmap.width;\r\n\r\n            videoOffScreens[e.data.id].height = e.data.bitmap.height;\r\n\r\n            videoOffScreens[e.data.id].getContext('bitmaprenderer').transferFromImageBitmap(e.data.bitmap);\r\n\r\n            videoOffScreens[e.data.id].texture.update();\r\n            break;\r\n        case 'createTextSource':\r\n            WBS.getScenesWrapper().getSelectedScene().getSourcesWrapper().createTextSource(e.data.id, e.data.text, e.data.style);\r\n            break;\r\n        case 'addSource':\r\n            WBS.getScenesWrapper().getSelectedScene().getSourcesWrapper().addSource();\r\n            break;\r\n        case 'removeSource':\r\n            WBS.getScenesWrapper().getSelectedScene().getSourcesWrapper().removeSource(e.data.id);\r\n        default:\r\n            break;\r\n    }\r\n})\n\n//# sourceURL=webpack://webBroadcastCore/./src/worker.js?");

/***/ }),

/***/ "./src/lib/live2d/live2d.min.js":
/*!**************************************!*\
  !*** ./src/lib/live2d/live2d.min.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"8077bdd8869b6fd7dd57.js\";\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/live2d/live2d.min.js?");

/***/ }),

/***/ "./src/lib/live2d/live2dcubismcore.min.js":
/*!************************************************!*\
  !*** ./src/lib/live2d/live2dcubismcore.min.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"7ecb42024d61c36ef53d.js\";\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/live2d/live2dcubismcore.min.js?");

/***/ }),

/***/ "./src/lib/utils/camera_utils.js":
/*!***************************************!*\
  !*** ./src/lib/utils/camera_utils.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"fddd7d51b92c57152682.js\";\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/utils/camera_utils.js?");

/***/ }),

/***/ "./src/lib/utils/face_mesh.js":
/*!************************************!*\
  !*** ./src/lib/utils/face_mesh.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"52ed4c440de9e3d0f9ff.js\";\n\n//# sourceURL=webpack://webBroadcastCore/./src/lib/utils/face_mesh.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_kalidokit_dist_index_js-node_modules_pixi-live2d-display_lib_index_js-no-af7933"], () => (__webpack_require__("./src/worker.js")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames not based on template
/******/ 			if (chunkId === "vendors-node_modules_kalidokit_dist_index_js-node_modules_pixi-live2d-display_lib_index_js-no-af7933") return "27f630ee4afe5c5957c4.bundle.js";
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"src_worker_js": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkwebBroadcastCore"] = self["webpackChunkwebBroadcastCore"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return __webpack_require__.e("vendors-node_modules_kalidokit_dist_index_js-node_modules_pixi-live2d-display_lib_index_js-no-af7933").then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});